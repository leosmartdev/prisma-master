// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixBCL prefix
	PrefixBCL = "BCL"
)

// BCL represents fix data.
type CoreBCL struct {
	StationID string

	StationIDValidity bool

	PositionDource uint32

	PositionDourceValidity bool

	Latitude float64

	LatitudeValidity bool

	LatitudeDirection string

	LatitudeDirectionValidity bool

	Longitude float64

	LongitudeValidity bool

	LongitudeDirection string

	LongitudeDirectionValidity bool

	Name string

	NameValidity bool

	Status string

	StatusValidity bool
}

type BCL struct {
	BaseSentence
	CoreBCL
}

func NewBCL(sentence BaseSentence) *BCL {
	s := new(BCL)
	s.BaseSentence = sentence

	s.StationIDValidity = false

	s.PositionDourceValidity = false

	s.LatitudeValidity = false

	s.LatitudeDirectionValidity = false

	s.LongitudeValidity = false

	s.LongitudeDirectionValidity = false

	s.NameValidity = false

	s.StatusValidity = false

	return s
}

func (s *BCL) parse() error {
	var err error

	if s.Format != PrefixBCL {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixBCL)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			s.StationID = s.Fields[0]
			s.StationIDValidity = true
		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseUint(s.Fields[1], 10, 32)
			if err != nil {
				return fmt.Errorf("BCL decode variation error: %s", s.Fields[1])
			} else {
				s.CoreBCL.PositionDource = uint32(i)
				s.CoreBCL.PositionDourceValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseFloat(s.Fields[2], 64)
			if err != nil {
				return fmt.Errorf("BCL decode variation error: %s", s.Fields[2])
			} else {
				s.CoreBCL.Latitude = float64(i)
				s.CoreBCL.LatitudeValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			s.LatitudeDirection = s.Fields[3]
			s.LatitudeDirectionValidity = true
		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseFloat(s.Fields[4], 64)
			if err != nil {
				return fmt.Errorf("BCL decode variation error: %s", s.Fields[4])
			} else {
				s.CoreBCL.Longitude = float64(i)
				s.CoreBCL.LongitudeValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			s.LongitudeDirection = s.Fields[5]
			s.LongitudeDirectionValidity = true
		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			s.Name = s.Fields[6]
			s.NameValidity = true
		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			s.Status = s.Fields[7]
			s.StatusValidity = true
		}
	}

	return nil
}

func (s *BCL) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixBCL {
		err := fmt.Errorf("Sentence format %s is not a BCL sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.StationIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreBCL.StationID

		} else {
			Raw = Raw + "," + s.CoreBCL.StationID
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.PositionDourceValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCL.PositionDource), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCL.PositionDource), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LatitudeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreBCL.Latitude, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreBCL.Latitude, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LatitudeDirectionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreBCL.LatitudeDirection

		} else {
			Raw = Raw + "," + s.CoreBCL.LatitudeDirection
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LongitudeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreBCL.Longitude, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreBCL.Longitude, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LongitudeDirectionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreBCL.LongitudeDirection

		} else {
			Raw = Raw + "," + s.CoreBCL.LongitudeDirection
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.NameValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreBCL.Name

		} else {
			Raw = Raw + "," + s.CoreBCL.Name
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StatusValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreBCL.Status

		} else {
			Raw = Raw + "," + s.CoreBCL.Status
		}
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
