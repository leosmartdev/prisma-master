// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixADS prefix
	PrefixADS = "ADS"
)

// ADS represents fix data.
type CoreADS struct {
	StationID string

	StationIDValidity bool

	UtcTime float64

	UtcTimeValidity bool

	AlarmStatus string

	AlarmStatusValidity bool

	TimeSyncMethod uint32

	TimeSyncMethodValidity bool

	PositionSource string

	PositionSourceValidity bool

	UtcTimingSource string

	UtcTimingSourceValidity bool
}

type ADS struct {
	BaseSentence
	CoreADS
}

func NewADS(sentence BaseSentence) *ADS {
	s := new(ADS)
	s.BaseSentence = sentence

	s.StationIDValidity = false

	s.UtcTimeValidity = false

	s.AlarmStatusValidity = false

	s.TimeSyncMethodValidity = false

	s.PositionSourceValidity = false

	s.UtcTimingSourceValidity = false

	return s
}

func (s *ADS) parse() error {
	var err error

	if s.Format != PrefixADS {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixADS)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			s.StationID = s.Fields[0]
			s.StationIDValidity = true
		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseFloat(s.Fields[1], 64)
			if err != nil {
				return fmt.Errorf("ADS decode variation error: %s", s.Fields[1])
			} else {
				s.CoreADS.UtcTime = float64(i)
				s.CoreADS.UtcTimeValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			s.AlarmStatus = s.Fields[2]
			s.AlarmStatusValidity = true
		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			i, err := strconv.ParseUint(s.Fields[3], 10, 32)
			if err != nil {
				return fmt.Errorf("ADS decode variation error: %s", s.Fields[3])
			} else {
				s.CoreADS.TimeSyncMethod = uint32(i)
				s.CoreADS.TimeSyncMethodValidity = true
			}

		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			s.PositionSource = s.Fields[4]
			s.PositionSourceValidity = true
		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			s.UtcTimingSource = s.Fields[5]
			s.UtcTimingSourceValidity = true
		}
	}

	return nil
}

func (s *ADS) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixADS {
		err := fmt.Errorf("Sentence format %s is not a ADS sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.StationIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreADS.StationID

		} else {
			Raw = Raw + "," + s.CoreADS.StationID
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.UtcTimeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreADS.UtcTime, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreADS.UtcTime, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.AlarmStatusValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreADS.AlarmStatus

		} else {
			Raw = Raw + "," + s.CoreADS.AlarmStatus
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.TimeSyncMethodValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreADS.TimeSyncMethod), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreADS.TimeSyncMethod), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.PositionSourceValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreADS.PositionSource

		} else {
			Raw = Raw + "," + s.CoreADS.PositionSource
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.UtcTimingSourceValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreADS.UtcTimingSource

		} else {
			Raw = Raw + "," + s.CoreADS.UtcTimingSource
		}
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
