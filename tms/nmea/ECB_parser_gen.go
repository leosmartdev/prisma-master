// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixECB prefix
	PrefixECB = "ECB"
)

// ECB represents fix data.
type CoreECB struct {
	StationID string

	StationIDValidity bool

	MessageID uint32

	MessageIDValidity bool

	ReferenceUtcMinuteChannelA uint32

	ReferenceUtcMinuteChannelAValidity bool

	ReferenceSlotChannelA int32

	ReferenceSlotChannelAValidity bool

	SlotIntervalChannelA uint32

	SlotIntervalChannelAValidity bool

	SlotCountChannelA uint32

	SlotCountChannelAValidity bool

	ReferenceUtcMinuteChannelB uint32

	ReferenceUtcMinuteChannelBValidity bool

	ReferenceSlotChannelB int32

	ReferenceSlotChannelBValidity bool

	SlotIntervalChannelB uint32

	SlotIntervalChannelBValidity bool

	SlotCountChannelB uint32

	SlotCountChannelBValidity bool

	Status string

	StatusValidity bool
}

type ECB struct {
	BaseSentence
	CoreECB
}

func NewECB(sentence BaseSentence) *ECB {
	s := new(ECB)
	s.BaseSentence = sentence

	s.StationIDValidity = false

	s.MessageIDValidity = false

	s.ReferenceUtcMinuteChannelAValidity = false

	s.ReferenceSlotChannelAValidity = false

	s.SlotIntervalChannelAValidity = false

	s.SlotCountChannelAValidity = false

	s.ReferenceUtcMinuteChannelBValidity = false

	s.ReferenceSlotChannelBValidity = false

	s.SlotIntervalChannelBValidity = false

	s.SlotCountChannelBValidity = false

	s.StatusValidity = false

	return s
}

func (s *ECB) parse() error {
	var err error

	if s.Format != PrefixECB {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixECB)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			s.StationID = s.Fields[0]
			s.StationIDValidity = true
		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseUint(s.Fields[1], 10, 32)
			if err != nil {
				return fmt.Errorf("ECB decode variation error: %s", s.Fields[1])
			} else {
				s.CoreECB.MessageID = uint32(i)
				s.CoreECB.MessageIDValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseUint(s.Fields[2], 10, 32)
			if err != nil {
				return fmt.Errorf("ECB decode variation error: %s", s.Fields[2])
			} else {
				s.CoreECB.ReferenceUtcMinuteChannelA = uint32(i)
				s.CoreECB.ReferenceUtcMinuteChannelAValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			i, err := strconv.ParseInt(s.Fields[3], 10, 32)
			if err != nil {
				return fmt.Errorf("ECB decode variation error: %s", s.Fields[3])
			} else {
				s.CoreECB.ReferenceSlotChannelA = int32(i)
				s.CoreECB.ReferenceSlotChannelAValidity = true
			}

		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseUint(s.Fields[4], 10, 32)
			if err != nil {
				return fmt.Errorf("ECB decode variation error: %s", s.Fields[4])
			} else {
				s.CoreECB.SlotIntervalChannelA = uint32(i)
				s.CoreECB.SlotIntervalChannelAValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			i, err := strconv.ParseUint(s.Fields[5], 10, 32)
			if err != nil {
				return fmt.Errorf("ECB decode variation error: %s", s.Fields[5])
			} else {
				s.CoreECB.SlotCountChannelA = uint32(i)
				s.CoreECB.SlotCountChannelAValidity = true
			}

		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			i, err := strconv.ParseUint(s.Fields[6], 10, 32)
			if err != nil {
				return fmt.Errorf("ECB decode variation error: %s", s.Fields[6])
			} else {
				s.CoreECB.ReferenceUtcMinuteChannelB = uint32(i)
				s.CoreECB.ReferenceUtcMinuteChannelBValidity = true
			}

		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			i, err := strconv.ParseInt(s.Fields[7], 10, 32)
			if err != nil {
				return fmt.Errorf("ECB decode variation error: %s", s.Fields[7])
			} else {
				s.CoreECB.ReferenceSlotChannelB = int32(i)
				s.CoreECB.ReferenceSlotChannelBValidity = true
			}

		}
	}

	if len(s.Fields) == 8 {
		return nil
	} else {
		if s.Fields[8] != "" {
			i, err := strconv.ParseUint(s.Fields[8], 10, 32)
			if err != nil {
				return fmt.Errorf("ECB decode variation error: %s", s.Fields[8])
			} else {
				s.CoreECB.SlotIntervalChannelB = uint32(i)
				s.CoreECB.SlotIntervalChannelBValidity = true
			}

		}
	}

	if len(s.Fields) == 9 {
		return nil
	} else {
		if s.Fields[9] != "" {
			i, err := strconv.ParseUint(s.Fields[9], 10, 32)
			if err != nil {
				return fmt.Errorf("ECB decode variation error: %s", s.Fields[9])
			} else {
				s.CoreECB.SlotCountChannelB = uint32(i)
				s.CoreECB.SlotCountChannelBValidity = true
			}

		}
	}

	if len(s.Fields) == 10 {
		return nil
	} else {
		if s.Fields[10] != "" {
			s.Status = s.Fields[10]
			s.StatusValidity = true
		}
	}

	return nil
}

func (s *ECB) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixECB {
		err := fmt.Errorf("Sentence format %s is not a ECB sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.StationIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreECB.StationID

		} else {
			Raw = Raw + "," + s.CoreECB.StationID
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.MessageIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.MessageID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.MessageID), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ReferenceUtcMinuteChannelAValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.ReferenceUtcMinuteChannelA), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.ReferenceUtcMinuteChannelA), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ReferenceSlotChannelAValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatInt(int64(s.CoreECB.ReferenceSlotChannelA), 10)

		} else {
			Raw = Raw + "," + strconv.FormatInt(int64(s.CoreECB.ReferenceSlotChannelA), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SlotIntervalChannelAValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.SlotIntervalChannelA), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.SlotIntervalChannelA), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SlotCountChannelAValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.SlotCountChannelA), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.SlotCountChannelA), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ReferenceUtcMinuteChannelBValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.ReferenceUtcMinuteChannelB), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.ReferenceUtcMinuteChannelB), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ReferenceSlotChannelBValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatInt(int64(s.CoreECB.ReferenceSlotChannelB), 10)

		} else {
			Raw = Raw + "," + strconv.FormatInt(int64(s.CoreECB.ReferenceSlotChannelB), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SlotIntervalChannelBValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.SlotIntervalChannelB), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.SlotIntervalChannelB), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SlotCountChannelBValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.SlotCountChannelB), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreECB.SlotCountChannelB), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StatusValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreECB.Status

		} else {
			Raw = Raw + "," + s.CoreECB.Status
		}
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
