//Single Position report(0x06), Iridium/3G
// Code generated by omnicom; DO NOT EDIT
package omnicom

import (
	"errors"
	"strconv"
)

type SPR struct {
	Header                  byte
	Date_Position           Date_Position
	Move                    Move
	Period                  uint32
	Extention_Bit_Beacon_ID uint32
	Beacon_ID               uint32
	Padding                 uint32
	CRC                     uint32
}

func (SPR *SPR) Parse(input string) error {
	var err error
	if len(input) > 144 { //136 {
		err = errors.New("Input message is longer than limit")
		return err
	}
	var count int = 0
	if count+8 > len(input) {
		err = errors.New("Input message length of SPR is shorter than required")
		return err
	}
	count = count + 8
	if count+70 > len(input) {
		err = errors.New("Input message length of SPR is shorter than required")
		return err
	}
	SPR.Date_Position = *new(Date_Position)
	err = SPR.Date_Position.parse(input[count : count+70])
	count = count + 70
	if err != nil {
		return err
	}
	if count+18 > len(input) {
		err = errors.New("Input message length of SPR is shorter than required")
		return err
	}
	SPR.Move = *new(Move)
	err = SPR.Move.parse(input[count : count+18])
	count = count + 18
	if err != nil {
		return err
	}
	var num uint64
	if count+9 > len(input) {
		err = errors.New("Input message length of SPR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+9], 2, 32)
	SPR.Period = uint32(num*5 - 0)
	count = count + 9
	if err != nil {
		return err
	}
	if count+1 > len(input) {
		err = errors.New("Input message length of SPR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	SPR.Extention_Bit_Beacon_ID = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	if SPR.Extention_Bit_Beacon_ID == 1 {
		if count+20 > len(input) {
			err = errors.New("Input message length of SPR is shorter than required")
			return err
		}
		num, err = strconv.ParseUint(input[count:count+20], 2, 32)
		SPR.Beacon_ID = uint32(num*1 - 0)
		count = count + 20
		if err != nil {
			return err
		}
	}
	if count+(8-count%8) > len(input) {
		err = errors.New("Input message length of SPR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+(8-count%8)], 2, 32)
	SPR.Padding = uint32(num*1 - 0)
	count = count + (8 - count%8)
	if err != nil {
		return err
	}
	if count+8 > len(input) {
		err = errors.New("Input message length of SPR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	SPR.CRC = uint32(num*1 - 0)
	count = count + 8
	if err != nil {
		return err
	}
	return err
}
func (SPR *SPR) Encode() ([]byte, error) {
	var str string
	var s string
	var err error
	str += pad(strconv.FormatUint(uint64(SPR.Header), 2), 8)
	s, err = SPR.Date_Position.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = SPR.Move.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((SPR.Period+0)/5), 2), 9)
	if len(s) > 9 {
		err = errors.New("Value assigned for SPR.Period exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((SPR.Extention_Bit_Beacon_ID+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for SPR.Extention_Bit_Beacon_ID exceeds limit")
		return []byte{}, err
	}
	str += s

	if SPR.Extention_Bit_Beacon_ID == 1 {
		s = pad(strconv.FormatUint(uint64((SPR.Beacon_ID+0)/1), 2), 20)
		if len(s) > 20 {
			err = errors.New("Value assigned for SPR.Beacon_ID exceeds limit")
			return []byte{}, err
		}
		str += s

	}
	s = pad(strconv.FormatUint(uint64((SPR.Padding+0)/1), 2), 8-len(str)%8)
	if len(s) > (8 - len(str)%8) {
		err = errors.New("Value assigned for SPR.Padding exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((SPR.CRC+0)/1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for SPR.CRC exceeds limit")
		return []byte{}, err
	}
	str += s

	str = attachCRC(str)
	byteList, err := decToByte(str)
	return byteList, err
}
func (SPR *SPR) getHeader() byte {
	return SPR.Header
}
func (SPR *SPR) getCRC() uint32 {
	return SPR.CRC
}
func (SPR *SPR) setCRC(crc uint32) {
	SPR.CRC = crc
}
