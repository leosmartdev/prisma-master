// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixABM prefix
	PrefixABM = "ABM"
)

// ABM represents fix data.
type CoreABM struct {
	SentenceCount uint32

	SentenceCountValidity bool

	SentenceIndex uint32

	SentenceIndexValidity bool

	SeqMsgID uint32

	SeqMsgIDValidity bool

	DestinationID uint32

	DestinationIDValidity bool

	Channel uint32

	ChannelValidity bool

	MessageID uint32

	MessageIDValidity bool

	Text string

	TextValidity bool

	FillBits uint32

	FillBitsValidity bool
}

type ABM struct {
	BaseSentence
	CoreABM
}

func NewABM(sentence BaseSentence) *ABM {
	s := new(ABM)
	s.BaseSentence = sentence

	s.SentenceCountValidity = false

	s.SentenceIndexValidity = false

	s.SeqMsgIDValidity = false

	s.DestinationIDValidity = false

	s.ChannelValidity = false

	s.MessageIDValidity = false

	s.TextValidity = false

	s.FillBitsValidity = false

	return s
}

func (s *ABM) parse() error {
	var err error

	if s.Format != PrefixABM {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixABM)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseUint(s.Fields[0], 10, 32)
			if err != nil {
				return fmt.Errorf("ABM decode variation error: %s", s.Fields[0])
			} else {
				s.CoreABM.SentenceCount = uint32(i)
				s.CoreABM.SentenceCountValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseUint(s.Fields[1], 10, 32)
			if err != nil {
				return fmt.Errorf("ABM decode variation error: %s", s.Fields[1])
			} else {
				s.CoreABM.SentenceIndex = uint32(i)
				s.CoreABM.SentenceIndexValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseUint(s.Fields[2], 10, 32)
			if err != nil {
				return fmt.Errorf("ABM decode variation error: %s", s.Fields[2])
			} else {
				s.CoreABM.SeqMsgID = uint32(i)
				s.CoreABM.SeqMsgIDValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			i, err := strconv.ParseUint(s.Fields[3], 10, 32)
			if err != nil {
				return fmt.Errorf("ABM decode variation error: %s", s.Fields[3])
			} else {
				s.CoreABM.DestinationID = uint32(i)
				s.CoreABM.DestinationIDValidity = true
			}

		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseUint(s.Fields[4], 10, 32)
			if err != nil {
				return fmt.Errorf("ABM decode variation error: %s", s.Fields[4])
			} else {
				s.CoreABM.Channel = uint32(i)
				s.CoreABM.ChannelValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			i, err := strconv.ParseUint(s.Fields[5], 10, 32)
			if err != nil {
				return fmt.Errorf("ABM decode variation error: %s", s.Fields[5])
			} else {
				s.CoreABM.MessageID = uint32(i)
				s.CoreABM.MessageIDValidity = true
			}

		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			s.Text = s.Fields[6]
			s.TextValidity = true
		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			i, err := strconv.ParseUint(s.Fields[7], 10, 32)
			if err != nil {
				return fmt.Errorf("ABM decode variation error: %s", s.Fields[7])
			} else {
				s.CoreABM.FillBits = uint32(i)
				s.CoreABM.FillBitsValidity = true
			}

		}
	}

	return nil
}

func (s *ABM) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixABM {
		err := fmt.Errorf("Sentence format %s is not a ABM sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.SentenceCountValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.SentenceCount), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.SentenceCount), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SentenceIndexValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.SentenceIndex), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.SentenceIndex), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SeqMsgIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.SeqMsgID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.SeqMsgID), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.DestinationIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.DestinationID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.DestinationID), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ChannelValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.Channel), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.Channel), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.MessageIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.MessageID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.MessageID), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.TextValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreABM.Text

		} else {
			Raw = Raw + "," + s.CoreABM.Text
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.FillBitsValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.FillBits), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreABM.FillBits), 10)
		}

	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
