//Upload Geofence(0x35) for polygon shape, Iridium/3G
// Code generated by omnicom; DO NOT EDIT
package omnicom

import (
	"errors"
	"strconv"
)

type UG_Polygon struct {
	Header       byte
	Msg_ID       uint32
	Date         Date
	GEO_ID       uint32
	Shape        uint32
	NAME         []byte
	TYPE         uint32
	Priority     uint32
	Activated    uint32
	Setting      Setting
	Number_Point uint32
	Position     []Position
	Padding      uint32
	CRC          uint32
}

func (UG_Polygon *UG_Polygon) Parse(input string) error {
	var err error
	if len(input) > 4584 {
		err = errors.New("Input message is longer than limit")
		return err
	}
	var count int = 0
	if count+8 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	count = count + 8
	var num uint64
	if count+12 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+12], 2, 32)
	UG_Polygon.Msg_ID = uint32(num*1 - 0)
	count = count + 12
	if err != nil {
		return err
	}
	if count+27 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	UG_Polygon.Date = *new(Date)
	err = UG_Polygon.Date.parse(input[count : count+27])
	count = count + 27
	if err != nil {
		return err
	}
	if count+32 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+32], 2, 32)
	UG_Polygon.GEO_ID = uint32(num*1 - 0)
	count = count + 32
	if err != nil {
		return err
	}
	if count+1 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	UG_Polygon.Shape = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	if count+160 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	UG_Polygon.NAME, err = decodeToByte(input[count : count+160])
	count = count + 160
	if err != nil {
		return err
	}
	if count+8 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	UG_Polygon.TYPE = uint32(num*1 - 0)
	count = count + 8
	if err != nil {
		return err
	}
	if count+2 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+2], 2, 32)
	UG_Polygon.Priority = uint32(num*1 - 0)
	count = count + 2
	if err != nil {
		return err
	}
	if count+1 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	UG_Polygon.Activated = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	if count+17 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	UG_Polygon.Setting = *new(Setting)
	err = UG_Polygon.Setting.parse(input[count : count+17])
	count = count + 17
	if err != nil {
		return err
	}
	if count+7 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+7], 2, 32)
	UG_Polygon.Number_Point = uint32(num*1 - 0)
	count = count + 7
	if err != nil {
		return err
	}
	UG_Polygon.Position = make([]Position, int(UG_Polygon.Number_Point))
	for i := 0; i < int(UG_Polygon.Number_Point); i++ {
		if count+43 > len(input) {
			err = errors.New("Input message length of UG_Polygon is shorter than required")
			return err
		}
		UG_Polygon.Position[i] = *new(Position)
		err = UG_Polygon.Position[i].parse(input[count : count+43])
		count = count + 43
		if err != nil {
			return err
		}
	}
	if count+(8-count%8) > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+(8-count%8)], 2, 32)
	UG_Polygon.Padding = uint32(num*1 - 0)
	count = count + (8 - count%8)
	if err != nil {
		return err
	}
	if count+8 > len(input) {
		err = errors.New("Input message length of UG_Polygon is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	UG_Polygon.CRC = uint32(num*1 - 0)
	count = count + 8
	if err != nil {
		return err
	}
	return err
}
func (UG_Polygon *UG_Polygon) Encode() ([]byte, error) {
	var str string
	var s string
	var err error
	str += pad(strconv.FormatUint(uint64(UG_Polygon.Header), 2), 8)
	s = pad(strconv.FormatUint(uint64((UG_Polygon.Msg_ID+0)/1), 2), 12)
	if len(s) > 12 {
		err = errors.New("Value assigned for UG_Polygon.Msg_ID exceeds limit")
		return []byte{}, err
	}
	str += s

	s, err = UG_Polygon.Date.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UG_Polygon.GEO_ID+0)/1), 2), 32)
	if len(s) > 32 {
		err = errors.New("Value assigned for UG_Polygon.GEO_ID exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UG_Polygon.Shape+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for UG_Polygon.Shape exceeds limit")
		return []byte{}, err
	}
	str += s

	s, err = encodeFromByte(UG_Polygon.NAME, 160)
	if err != nil {
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UG_Polygon.TYPE+0)/1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for UG_Polygon.TYPE exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UG_Polygon.Priority+0)/1), 2), 2)
	if len(s) > 2 {
		err = errors.New("Value assigned for UG_Polygon.Priority exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UG_Polygon.Activated+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for UG_Polygon.Activated exceeds limit")
		return []byte{}, err
	}
	str += s

	s, err = UG_Polygon.Setting.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UG_Polygon.Number_Point+0)/1), 2), 7)
	if len(s) > 7 {
		err = errors.New("Value assigned for UG_Polygon.Number_Point exceeds limit")
		return []byte{}, err
	}
	str += s

	for i := 0; i < int(UG_Polygon.Number_Point); i++ {
		s, err = UG_Polygon.Position[i].encode()
		if err != nil {
			return []byte{}, err
		}
		str += s
	}

	s = pad(strconv.FormatUint(uint64((UG_Polygon.Padding+0)/1), 2), 8-len(str)%8)
	if len(s) > (8 - len(str)%8) {
		err = errors.New("Value assigned for UG_Polygon.Padding exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UG_Polygon.CRC+0)/1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for UG_Polygon.CRC exceeds limit")
		return []byte{}, err
	}
	str += s

	str = attachCRC(str)
	byteList, err := decToByte(str)
	return byteList, err
}
func (UG_Polygon *UG_Polygon) getHeader() byte {
	return UG_Polygon.Header
}
func (UG_Polygon *UG_Polygon) getCRC() uint32 {
	return UG_Polygon.CRC
}
func (UG_Polygon *UG_Polygon) setCRC(crc uint32) {
	UG_Polygon.CRC = crc
}
