// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixFSR prefix
	PrefixFSR = "FSR"
)

// FSR represents fix data.
type CoreFSR struct {
	StationID string

	StationIDValidity bool

	UtcTime float64

	UtcTimeValidity bool

	Channel string

	ChannelValidity bool

	SlotsOccupiedByMessagesReceived uint32

	SlotsOccupiedByMessagesReceivedValidity bool

	SlotsOccupiedBybaseStation uint32

	SlotsOccupiedBybaseStationValidity bool

	CrcFailureCount uint32

	CrcFailureCountValidity bool

	ExternalSlotReservations uint32

	ExternalSlotReservationsValidity bool

	BaseStationSlotReservations uint32

	BaseStationSlotReservationsValidity bool

	AverageNoiseLevel float64

	AverageNoiseLevelValidity bool

	SlotsAboveNoiseCount uint32

	SlotsAboveNoiseCountValidity bool
}

type FSR struct {
	BaseSentence
	CoreFSR
}

func NewFSR(sentence BaseSentence) *FSR {
	s := new(FSR)
	s.BaseSentence = sentence

	s.StationIDValidity = false

	s.UtcTimeValidity = false

	s.ChannelValidity = false

	s.SlotsOccupiedByMessagesReceivedValidity = false

	s.SlotsOccupiedBybaseStationValidity = false

	s.CrcFailureCountValidity = false

	s.ExternalSlotReservationsValidity = false

	s.BaseStationSlotReservationsValidity = false

	s.AverageNoiseLevelValidity = false

	s.SlotsAboveNoiseCountValidity = false

	return s
}

func (s *FSR) parse() error {
	var err error

	if s.Format != PrefixFSR {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixFSR)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			s.StationID = s.Fields[0]
			s.StationIDValidity = true
		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseFloat(s.Fields[1], 64)
			if err != nil {
				return fmt.Errorf("FSR decode variation error: %s", s.Fields[1])
			} else {
				s.CoreFSR.UtcTime = float64(i)
				s.CoreFSR.UtcTimeValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			s.Channel = s.Fields[2]
			s.ChannelValidity = true
		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			i, err := strconv.ParseUint(s.Fields[3], 10, 32)
			if err != nil {
				return fmt.Errorf("FSR decode variation error: %s", s.Fields[3])
			} else {
				s.CoreFSR.SlotsOccupiedByMessagesReceived = uint32(i)
				s.CoreFSR.SlotsOccupiedByMessagesReceivedValidity = true
			}

		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseUint(s.Fields[4], 10, 32)
			if err != nil {
				return fmt.Errorf("FSR decode variation error: %s", s.Fields[4])
			} else {
				s.CoreFSR.SlotsOccupiedBybaseStation = uint32(i)
				s.CoreFSR.SlotsOccupiedBybaseStationValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			i, err := strconv.ParseUint(s.Fields[5], 10, 32)
			if err != nil {
				return fmt.Errorf("FSR decode variation error: %s", s.Fields[5])
			} else {
				s.CoreFSR.CrcFailureCount = uint32(i)
				s.CoreFSR.CrcFailureCountValidity = true
			}

		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			i, err := strconv.ParseUint(s.Fields[6], 10, 32)
			if err != nil {
				return fmt.Errorf("FSR decode variation error: %s", s.Fields[6])
			} else {
				s.CoreFSR.ExternalSlotReservations = uint32(i)
				s.CoreFSR.ExternalSlotReservationsValidity = true
			}

		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			i, err := strconv.ParseUint(s.Fields[7], 10, 32)
			if err != nil {
				return fmt.Errorf("FSR decode variation error: %s", s.Fields[7])
			} else {
				s.CoreFSR.BaseStationSlotReservations = uint32(i)
				s.CoreFSR.BaseStationSlotReservationsValidity = true
			}

		}
	}

	if len(s.Fields) == 8 {
		return nil
	} else {
		if s.Fields[8] != "" {
			i, err := strconv.ParseFloat(s.Fields[8], 64)
			if err != nil {
				return fmt.Errorf("FSR decode variation error: %s", s.Fields[8])
			} else {
				s.CoreFSR.AverageNoiseLevel = float64(i)
				s.CoreFSR.AverageNoiseLevelValidity = true
			}

		}
	}

	if len(s.Fields) == 9 {
		return nil
	} else {
		if s.Fields[9] != "" {
			i, err := strconv.ParseUint(s.Fields[9], 10, 32)
			if err != nil {
				return fmt.Errorf("FSR decode variation error: %s", s.Fields[9])
			} else {
				s.CoreFSR.SlotsAboveNoiseCount = uint32(i)
				s.CoreFSR.SlotsAboveNoiseCountValidity = true
			}

		}
	}

	return nil
}

func (s *FSR) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixFSR {
		err := fmt.Errorf("Sentence format %s is not a FSR sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.StationIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreFSR.StationID

		} else {
			Raw = Raw + "," + s.CoreFSR.StationID
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.UtcTimeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreFSR.UtcTime, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreFSR.UtcTime, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ChannelValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreFSR.Channel

		} else {
			Raw = Raw + "," + s.CoreFSR.Channel
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SlotsOccupiedByMessagesReceivedValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.SlotsOccupiedByMessagesReceived), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.SlotsOccupiedByMessagesReceived), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SlotsOccupiedBybaseStationValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.SlotsOccupiedBybaseStation), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.SlotsOccupiedBybaseStation), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.CrcFailureCountValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.CrcFailureCount), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.CrcFailureCount), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ExternalSlotReservationsValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.ExternalSlotReservations), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.ExternalSlotReservations), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.BaseStationSlotReservationsValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.BaseStationSlotReservations), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.BaseStationSlotReservations), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.AverageNoiseLevelValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreFSR.AverageNoiseLevel, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreFSR.AverageNoiseLevel, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SlotsAboveNoiseCountValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.SlotsAboveNoiseCount), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreFSR.SlotsAboveNoiseCount), 10)
		}

	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
