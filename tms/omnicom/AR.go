//Alert Report(0x02), Iridium/3G
// Code generated by omnicom; DO NOT EDIT
package omnicom

import (
	"errors"
	"strconv"
)

type AR struct {
	Header                  byte
	Msg_ID                  uint32
	Date_Position           Date_Position
	Date_Event              Date_Event
	Power_Up                Power_Up
	Power_Down              Power_Down
	Battery_Alert           Battery_Alert
	Intrusion_Alert         Intrusion_Alert
	No_Position_Fix         No_Position_Fix
	JB_Dome_Alert           JB_Dome_Alert
	Loss_Mobile_Com         Loss_Mobile_Com
	Daylight_Alert          Daylight_Alert
	Assistance_Alert        Assistance_Alert
	Test_Mode               Test_Mode
	Extention_Bit_Move      uint32
	Move                    Move
	Extention_Bit_Beacon_ID uint32
	Beacon_ID               uint32
	Padding                 uint32
	CRC                     uint32
}

func (AR *AR) Parse(input string) error {
	var err error
	if len(input) > 192 {
		err = errors.New("Input message is longer than limit")
		return err
	}
	var count int = 0
	if count+8 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	count = count + 8
	var num uint64
	if count+12 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+12], 2, 32)
	AR.Msg_ID = uint32(num*1 - 0)
	count = count + 12
	if err != nil {
		return err
	}
	if count+70 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.Date_Position = *new(Date_Position)
	err = AR.Date_Position.parse(input[count : count+70])
	count = count + 70
	if err != nil {
		return err
	}
	if count+27 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.Date_Event = *new(Date_Event)
	err = AR.Date_Event.parse(input[count : count+27])
	count = count + 27
	if err != nil {
		return err
	}
	if count+2 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.Power_Up = *new(Power_Up)
	err = AR.Power_Up.parse(input[count : count+2])
	count = count + 2
	if err != nil {
		return err
	}
	if count+2 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.Power_Down = *new(Power_Down)
	err = AR.Power_Down.parse(input[count : count+2])
	count = count + 2
	if err != nil {
		return err
	}
	if count+3 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.Battery_Alert = *new(Battery_Alert)
	err = AR.Battery_Alert.parse(input[count : count+3])
	count = count + 3
	if err != nil {
		return err
	}
	if count+2 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.Intrusion_Alert = *new(Intrusion_Alert)
	err = AR.Intrusion_Alert.parse(input[count : count+2])
	count = count + 2
	if err != nil {
		return err
	}
	if count+6 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.No_Position_Fix = *new(No_Position_Fix)
	err = AR.No_Position_Fix.parse(input[count : count+6])
	count = count + 6
	if err != nil {
		return err
	}
	if count+2 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.JB_Dome_Alert = *new(JB_Dome_Alert)
	err = AR.JB_Dome_Alert.parse(input[count : count+2])
	count = count + 2
	if err != nil {
		return err
	}
	if count+2 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.Loss_Mobile_Com = *new(Loss_Mobile_Com)
	err = AR.Loss_Mobile_Com.parse(input[count : count+2])
	count = count + 2
	if err != nil {
		return err
	}
	if count+2 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.Daylight_Alert = *new(Daylight_Alert)
	err = AR.Daylight_Alert.parse(input[count : count+2])
	count = count + 2
	if err != nil {
		return err
	}
	if count+2 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.Assistance_Alert = *new(Assistance_Alert)
	err = AR.Assistance_Alert.parse(input[count : count+2])
	count = count + 2
	if err != nil {
		return err
	}
	if count+2 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	AR.Test_Mode = *new(Test_Mode)
	err = AR.Test_Mode.parse(input[count : count+2])
	count = count + 2
	if err != nil {
		return err
	}
	if count+1 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	AR.Extention_Bit_Move = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	if AR.Extention_Bit_Move == 1 {
		if count+18 > len(input) {
			err = errors.New("Input message length of AR is shorter than required")
			return err
		}
		AR.Move = *new(Move)
		err = AR.Move.parse(input[count : count+18])
		count = count + 18
		if err != nil {
			return err
		}
	}
	if count+1 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	AR.Extention_Bit_Beacon_ID = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	if AR.Extention_Bit_Beacon_ID == 1 {
		if count+20 > len(input) {
			err = errors.New("Input message length of AR is shorter than required")
			return err
		}
		num, err = strconv.ParseUint(input[count:count+20], 2, 32)
		AR.Beacon_ID = uint32(num*1 - 0)
		count = count + 20
		if err != nil {
			return err
		}
	}
	if count+(8-count%8) > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+(8-count%8)], 2, 32)
	AR.Padding = uint32(num*1 - 0)
	count = count + (8 - count%8)
	if err != nil {
		return err
	}
	if count+8 > len(input) {
		err = errors.New("Input message length of AR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	AR.CRC = uint32(num*1 - 0)
	count = count + 8
	if err != nil {
		return err
	}
	return err
}
func (AR *AR) Encode() ([]byte, error) {
	var str string
	var s string
	var err error
	str += pad(strconv.FormatUint(uint64(AR.Header), 2), 8)
	s = pad(strconv.FormatUint(uint64((AR.Msg_ID+0)/1), 2), 12)
	if len(s) > 12 {
		err = errors.New("Value assigned for AR.Msg_ID exceeds limit")
		return []byte{}, err
	}
	str += s

	s, err = AR.Date_Position.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = AR.Date_Event.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = AR.Power_Up.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = AR.Power_Down.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = AR.Battery_Alert.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = AR.Intrusion_Alert.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = AR.No_Position_Fix.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = AR.JB_Dome_Alert.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = AR.Loss_Mobile_Com.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = AR.Daylight_Alert.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = AR.Assistance_Alert.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = AR.Test_Mode.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((AR.Extention_Bit_Move+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for AR.Extention_Bit_Move exceeds limit")
		return []byte{}, err
	}
	str += s

	if AR.Extention_Bit_Move == 1 {
		s, err = AR.Move.encode()
		if err != nil {
			return []byte{}, err
		}
		str += s

	}
	s = pad(strconv.FormatUint(uint64((AR.Extention_Bit_Beacon_ID+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for AR.Extention_Bit_Beacon_ID exceeds limit")
		return []byte{}, err
	}
	str += s

	if AR.Extention_Bit_Beacon_ID == 1 {
		s = pad(strconv.FormatUint(uint64((AR.Beacon_ID+0)/1), 2), 20)
		if len(s) > 20 {
			err = errors.New("Value assigned for AR.Beacon_ID exceeds limit")
			return []byte{}, err
		}
		str += s

	}
	s = pad(strconv.FormatUint(uint64((AR.Padding+0)/1), 2), 8-len(str)%8)
	if len(s) > (8 - len(str)%8) {
		err = errors.New("Value assigned for AR.Padding exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((AR.CRC+0)/1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for AR.CRC exceeds limit")
		return []byte{}, err
	}
	str += s

	str = attachCRC(str)
	byteList, err := decToByte(str)
	return byteList, err
}
func (AR *AR) getHeader() byte {
	return AR.Header
}
func (AR *AR) getCRC() uint32 {
	return AR.CRC
}
func (AR *AR) setCRC(crc uint32) {
	AR.CRC = crc
}
