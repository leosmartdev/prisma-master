// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixPFA prefix
	PrefixPFA = "PFA"
)

// PFA represents fix data.
type CorePFA struct {
	PfaChangeFactor float64

	PfaChangeFactorValidity bool
}

type PFA struct {
	BaseSentence
	CorePFA
}

func NewPFA(sentence BaseSentence) *PFA {
	s := new(PFA)
	s.BaseSentence = sentence

	s.PfaChangeFactorValidity = false

	return s
}

func (s *PFA) parse() error {
	var err error

	if s.Format != PrefixPFA {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixPFA)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseFloat(s.Fields[0], 64)
			if err != nil {
				return fmt.Errorf("PFA decode variation error: %s", s.Fields[0])
			} else {
				s.CorePFA.PfaChangeFactor = float64(i)
				s.CorePFA.PfaChangeFactorValidity = true
			}

		}
	}

	return nil
}

func (s *PFA) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixPFA {
		err := fmt.Errorf("Sentence format %s is not a PFA sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.PfaChangeFactorValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CorePFA.PfaChangeFactor, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CorePFA.PfaChangeFactor, 'f', -1, 64)
		}

	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
