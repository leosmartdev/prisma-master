// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixTFR prefix
	PrefixTFR = "TFR"
)

// TFR represents fix data.
type CoreTFR struct {
	VdmSentenceCount uint32

	VdmSentenceCountValidity bool

	VdmSeqMsgID uint32

	VdmSeqMsgIDValidity bool

	VdmChannel string

	VdmChannelValidity bool

	StationID string

	StationIDValidity bool

	ReqUtcFrame uint32

	ReqUtcFrameValidity bool

	ReqSlotNumber uint32

	ReqSlotNumberValidity bool

	AssignedUtcFrame uint32

	AssignedUtcFrameValidity bool

	AssignedSlotNumber uint32

	AssignedSlotNumberValidity bool

	AssignedSlotCount uint32

	AssignedSlotCountValidity bool

	Priority uint32

	PriorityValidity bool

	Status uint32

	StatusValidity bool
}

type TFR struct {
	BaseSentence
	CoreTFR
}

func NewTFR(sentence BaseSentence) *TFR {
	s := new(TFR)
	s.BaseSentence = sentence

	s.VdmSentenceCountValidity = false

	s.VdmSeqMsgIDValidity = false

	s.VdmChannelValidity = false

	s.StationIDValidity = false

	s.ReqUtcFrameValidity = false

	s.ReqSlotNumberValidity = false

	s.AssignedUtcFrameValidity = false

	s.AssignedSlotNumberValidity = false

	s.AssignedSlotCountValidity = false

	s.PriorityValidity = false

	s.StatusValidity = false

	return s
}

func (s *TFR) parse() error {
	var err error

	if s.Format != PrefixTFR {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixTFR)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseUint(s.Fields[0], 10, 32)
			if err != nil {
				return fmt.Errorf("TFR decode variation error: %s", s.Fields[0])
			} else {
				s.CoreTFR.VdmSentenceCount = uint32(i)
				s.CoreTFR.VdmSentenceCountValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseUint(s.Fields[1], 10, 32)
			if err != nil {
				return fmt.Errorf("TFR decode variation error: %s", s.Fields[1])
			} else {
				s.CoreTFR.VdmSeqMsgID = uint32(i)
				s.CoreTFR.VdmSeqMsgIDValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			s.VdmChannel = s.Fields[2]
			s.VdmChannelValidity = true
		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			s.StationID = s.Fields[3]
			s.StationIDValidity = true
		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseUint(s.Fields[4], 10, 32)
			if err != nil {
				return fmt.Errorf("TFR decode variation error: %s", s.Fields[4])
			} else {
				s.CoreTFR.ReqUtcFrame = uint32(i)
				s.CoreTFR.ReqUtcFrameValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			i, err := strconv.ParseUint(s.Fields[5], 10, 32)
			if err != nil {
				return fmt.Errorf("TFR decode variation error: %s", s.Fields[5])
			} else {
				s.CoreTFR.ReqSlotNumber = uint32(i)
				s.CoreTFR.ReqSlotNumberValidity = true
			}

		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			i, err := strconv.ParseUint(s.Fields[6], 10, 32)
			if err != nil {
				return fmt.Errorf("TFR decode variation error: %s", s.Fields[6])
			} else {
				s.CoreTFR.AssignedUtcFrame = uint32(i)
				s.CoreTFR.AssignedUtcFrameValidity = true
			}

		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			i, err := strconv.ParseUint(s.Fields[7], 10, 32)
			if err != nil {
				return fmt.Errorf("TFR decode variation error: %s", s.Fields[7])
			} else {
				s.CoreTFR.AssignedSlotNumber = uint32(i)
				s.CoreTFR.AssignedSlotNumberValidity = true
			}

		}
	}

	if len(s.Fields) == 8 {
		return nil
	} else {
		if s.Fields[8] != "" {
			i, err := strconv.ParseUint(s.Fields[8], 10, 32)
			if err != nil {
				return fmt.Errorf("TFR decode variation error: %s", s.Fields[8])
			} else {
				s.CoreTFR.AssignedSlotCount = uint32(i)
				s.CoreTFR.AssignedSlotCountValidity = true
			}

		}
	}

	if len(s.Fields) == 9 {
		return nil
	} else {
		if s.Fields[9] != "" {
			i, err := strconv.ParseUint(s.Fields[9], 10, 32)
			if err != nil {
				return fmt.Errorf("TFR decode variation error: %s", s.Fields[9])
			} else {
				s.CoreTFR.Priority = uint32(i)
				s.CoreTFR.PriorityValidity = true
			}

		}
	}

	if len(s.Fields) == 10 {
		return nil
	} else {
		if s.Fields[10] != "" {
			i, err := strconv.ParseUint(s.Fields[10], 10, 32)
			if err != nil {
				return fmt.Errorf("TFR decode variation error: %s", s.Fields[10])
			} else {
				s.CoreTFR.Status = uint32(i)
				s.CoreTFR.StatusValidity = true
			}

		}
	}

	return nil
}

func (s *TFR) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixTFR {
		err := fmt.Errorf("Sentence format %s is not a TFR sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.VdmSentenceCountValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.VdmSentenceCount), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.VdmSentenceCount), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.VdmSeqMsgIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.VdmSeqMsgID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.VdmSeqMsgID), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.VdmChannelValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTFR.VdmChannel

		} else {
			Raw = Raw + "," + s.CoreTFR.VdmChannel
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StationIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTFR.StationID

		} else {
			Raw = Raw + "," + s.CoreTFR.StationID
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ReqUtcFrameValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.ReqUtcFrame), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.ReqUtcFrame), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ReqSlotNumberValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.ReqSlotNumber), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.ReqSlotNumber), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.AssignedUtcFrameValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.AssignedUtcFrame), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.AssignedUtcFrame), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.AssignedSlotNumberValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.AssignedSlotNumber), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.AssignedSlotNumber), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.AssignedSlotCountValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.AssignedSlotCount), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.AssignedSlotCount), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.PriorityValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.Priority), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.Priority), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StatusValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.Status), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTFR.Status), 10)
		}

	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
