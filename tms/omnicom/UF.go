//Update Firmware(0x39), 3G
// Code generated by omnicom; DO NOT EDIT
package omnicom

import (
	"errors"
	"strconv"
)

type UF struct {
	Header           byte
	Date             Date
	ID_Msg           uint32
	Firmware_Target  uint32
	Flag_Last_Packet uint32
	Data_Address     uint32
	Data_Size        uint32
	Padding1         uint32
	Firmware_Data    []byte
	CRC              uint32
}

func (UF *UF) Parse(input string) error {
	var err error
	if len(input) > 213096 {
		err = errors.New("Input message is longer than limit")
		return err
	}
	var count int = 0
	if count+8 > len(input) {
		err = errors.New("Input message length of UF is shorter than required")
		return err
	}
	count = count + 8
	if count+27 > len(input) {
		err = errors.New("Input message length of UF is shorter than required")
		return err
	}
	UF.Date = *new(Date)
	err = UF.Date.parse(input[count : count+27])
	count = count + 27
	if err != nil {
		return err
	}
	var num uint64
	if count+12 > len(input) {
		err = errors.New("Input message length of UF is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+12], 2, 32)
	UF.ID_Msg = uint32(num*1 - 0)
	count = count + 12
	if err != nil {
		return err
	}
	if count+1 > len(input) {
		err = errors.New("Input message length of UF is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	UF.Firmware_Target = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	if count+1 > len(input) {
		err = errors.New("Input message length of UF is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	UF.Flag_Last_Packet = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	if count+24 > len(input) {
		err = errors.New("Input message length of UF is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+24], 2, 32)
	UF.Data_Address = uint32(num*1 - 0)
	count = count + 24
	if err != nil {
		return err
	}
	if count+16 > len(input) {
		err = errors.New("Input message length of UF is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+16], 2, 32)
	UF.Data_Size = uint32(num*1 - 0)
	count = count + 16
	if err != nil {
		return err
	}
	if count+7 > len(input) {
		err = errors.New("Input message length of UF is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+7], 2, 32)
	UF.Padding1 = uint32(num*1 - 0)
	count = count + 7
	if err != nil {
		return err
	}
	if count+int(UF.Data_Size)*8 > len(input) {
		err = errors.New("Input message length of UF is shorter than required")
		return err
	}
	if 212992 < int(UF.Data_Size)*8 {
		err = errors.New("UF.Data_Size is larger than limit")
		return err
	}
	UF.Firmware_Data, err = decodeToByte(input[count : count+int(UF.Data_Size)*8])
	count = count + int(UF.Data_Size)*8
	if err != nil {
		return err
	}
	if count+8 > len(input) {
		err = errors.New("Input message length of UF is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	UF.CRC = uint32(num*1 - 0)
	count = count + 8
	if err != nil {
		return err
	}
	return err
}
func (UF *UF) Encode() ([]byte, error) {
	var str string
	var s string
	var err error
	str += pad(strconv.FormatUint(uint64(UF.Header), 2), 8)
	s, err = UF.Date.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UF.ID_Msg+0)/1), 2), 12)
	if len(s) > 12 {
		err = errors.New("Value assigned for UF.ID_Msg exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UF.Firmware_Target+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for UF.Firmware_Target exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UF.Flag_Last_Packet+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for UF.Flag_Last_Packet exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UF.Data_Address+0)/1), 2), 24)
	if len(s) > 24 {
		err = errors.New("Value assigned for UF.Data_Address exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UF.Data_Size+0)/1), 2), 16)
	if len(s) > 16 {
		err = errors.New("Value assigned for UF.Data_Size exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UF.Padding1+0)/1), 2), 7)
	if len(s) > 7 {
		err = errors.New("Value assigned for UF.Padding1 exceeds limit")
		return []byte{}, err
	}
	str += s

	if 212992 < int(UF.Data_Size)*8 {
		err = errors.New("UF.Data_Size is larger than limit")
		return []byte{}, err
	}
	s, err = encodeFromByte(UF.Firmware_Data, int(UF.Data_Size)*8)
	if err != nil {
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((UF.CRC+0)/1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for UF.CRC exceeds limit")
		return []byte{}, err
	}
	str += s

	str = attachCRC(str)
	byteList, err := decToByte(str)
	return byteList, err
}
func (UF *UF) getHeader() byte {
	return UF.Header
}
func (UF *UF) getCRC() uint32 {
	return UF.CRC
}
func (UF *UF) setCRC(crc uint32) {
	UF.CRC = crc
}
