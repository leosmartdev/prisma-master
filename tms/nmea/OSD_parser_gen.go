// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixOSD prefix
	PrefixOSD = "OSD"
)

// OSD represents fix data.
type CoreOSD struct {
	Heading float64

	HeadingValidity bool

	DegreesTrue string

	DegreesTrueValidity bool

	Course float64

	CourseValidity bool

	CourseReference string

	CourseReferenceValidity bool

	Speed float64

	SpeedValidity bool

	SpeedReference string

	SpeedReferenceValidity bool

	Set float64

	SetValidity bool

	Drift float64

	DriftValidity bool

	SpeedUnits string

	SpeedUnitsValidity bool
}

type OSD struct {
	BaseSentence
	CoreOSD
}

func NewOSD(sentence BaseSentence) *OSD {
	s := new(OSD)
	s.BaseSentence = sentence

	s.HeadingValidity = false

	s.DegreesTrueValidity = false

	s.CourseValidity = false

	s.CourseReferenceValidity = false

	s.SpeedValidity = false

	s.SpeedReferenceValidity = false

	s.SetValidity = false

	s.DriftValidity = false

	s.SpeedUnitsValidity = false

	return s
}

func (s *OSD) parse() error {
	var err error

	if s.Format != PrefixOSD {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixOSD)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseFloat(s.Fields[0], 64)
			if err != nil {
				return fmt.Errorf("OSD decode variation error: %s", s.Fields[0])
			} else {
				s.CoreOSD.Heading = float64(i)
				s.CoreOSD.HeadingValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			s.DegreesTrue = s.Fields[1]
			s.DegreesTrueValidity = true
		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseFloat(s.Fields[2], 64)
			if err != nil {
				return fmt.Errorf("OSD decode variation error: %s", s.Fields[2])
			} else {
				s.CoreOSD.Course = float64(i)
				s.CoreOSD.CourseValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			s.CourseReference = s.Fields[3]
			s.CourseReferenceValidity = true
		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseFloat(s.Fields[4], 64)
			if err != nil {
				return fmt.Errorf("OSD decode variation error: %s", s.Fields[4])
			} else {
				s.CoreOSD.Speed = float64(i)
				s.CoreOSD.SpeedValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			s.SpeedReference = s.Fields[5]
			s.SpeedReferenceValidity = true
		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			i, err := strconv.ParseFloat(s.Fields[6], 64)
			if err != nil {
				return fmt.Errorf("OSD decode variation error: %s", s.Fields[6])
			} else {
				s.CoreOSD.Set = float64(i)
				s.CoreOSD.SetValidity = true
			}

		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			i, err := strconv.ParseFloat(s.Fields[7], 64)
			if err != nil {
				return fmt.Errorf("OSD decode variation error: %s", s.Fields[7])
			} else {
				s.CoreOSD.Drift = float64(i)
				s.CoreOSD.DriftValidity = true
			}

		}
	}

	if len(s.Fields) == 8 {
		return nil
	} else {
		if s.Fields[8] != "" {
			s.SpeedUnits = s.Fields[8]
			s.SpeedUnitsValidity = true
		}
	}

	return nil
}

func (s *OSD) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixOSD {
		err := fmt.Errorf("Sentence format %s is not a OSD sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.HeadingValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreOSD.Heading, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreOSD.Heading, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.DegreesTrueValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreOSD.DegreesTrue

		} else {
			Raw = Raw + "," + s.CoreOSD.DegreesTrue
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.CourseValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreOSD.Course, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreOSD.Course, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.CourseReferenceValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreOSD.CourseReference

		} else {
			Raw = Raw + "," + s.CoreOSD.CourseReference
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SpeedValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreOSD.Speed, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreOSD.Speed, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SpeedReferenceValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreOSD.SpeedReference

		} else {
			Raw = Raw + "," + s.CoreOSD.SpeedReference
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SetValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreOSD.Set, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreOSD.Set, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.DriftValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreOSD.Drift, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreOSD.Drift, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SpeedUnitsValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreOSD.SpeedUnits

		} else {
			Raw = Raw + "," + s.CoreOSD.SpeedUnits
		}
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
