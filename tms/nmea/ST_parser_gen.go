// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixST prefix
	PrefixST = "ST"
)

// ST represents fix data.
type CoreST struct {
	TimeInSecTillNewPfaPersists uint32

	TimeInSecTillNewPfaPersistsValidity bool

	CenterOfPfaWtoEinM int32

	CenterOfPfaWtoEinMValidity bool

	CenterOfPfaNtoSinM int32

	CenterOfPfaNtoSinMValidity bool

	TrackLocationWtoEinDeg float64

	TrackLocationWtoEinDegValidity bool

	TrackLocationNtoSinDeg float64

	TrackLocationNtoSinDegValidity bool

	HrzlDimofRegioninM uint32

	HrzlDimofRegioninMValidity bool

	VrtlDimofRegioninM uint32

	VrtlDimofRegioninMValidity bool

	PfaMultiplyingFactor float64

	PfaMultiplyingFactorValidity bool

	RegionShapeFlag uint32

	RegionShapeFlagValidity bool
}

type ST struct {
	BaseSentence
	CoreST
}

func NewST(sentence BaseSentence) *ST {
	s := new(ST)
	s.BaseSentence = sentence

	s.TimeInSecTillNewPfaPersistsValidity = false

	s.CenterOfPfaWtoEinMValidity = false

	s.CenterOfPfaNtoSinMValidity = false

	s.TrackLocationWtoEinDegValidity = false

	s.TrackLocationNtoSinDegValidity = false

	s.HrzlDimofRegioninMValidity = false

	s.VrtlDimofRegioninMValidity = false

	s.PfaMultiplyingFactorValidity = false

	s.RegionShapeFlagValidity = false

	return s
}

func (s *ST) parse() error {
	var err error

	if s.Format != PrefixST {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixST)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseUint(s.Fields[0], 10, 32)
			if err != nil {
				return fmt.Errorf("ST decode variation error: %s", s.Fields[0])
			} else {
				s.CoreST.TimeInSecTillNewPfaPersists = uint32(i)
				s.CoreST.TimeInSecTillNewPfaPersistsValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseInt(s.Fields[1], 10, 32)
			if err != nil {
				return fmt.Errorf("ST decode variation error: %s", s.Fields[1])
			} else {
				s.CoreST.CenterOfPfaWtoEinM = int32(i)
				s.CoreST.CenterOfPfaWtoEinMValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseInt(s.Fields[2], 10, 32)
			if err != nil {
				return fmt.Errorf("ST decode variation error: %s", s.Fields[2])
			} else {
				s.CoreST.CenterOfPfaNtoSinM = int32(i)
				s.CoreST.CenterOfPfaNtoSinMValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			i, err := strconv.ParseFloat(s.Fields[3], 64)
			if err != nil {
				return fmt.Errorf("ST decode variation error: %s", s.Fields[3])
			} else {
				s.CoreST.TrackLocationWtoEinDeg = float64(i)
				s.CoreST.TrackLocationWtoEinDegValidity = true
			}

		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseFloat(s.Fields[4], 64)
			if err != nil {
				return fmt.Errorf("ST decode variation error: %s", s.Fields[4])
			} else {
				s.CoreST.TrackLocationNtoSinDeg = float64(i)
				s.CoreST.TrackLocationNtoSinDegValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			i, err := strconv.ParseUint(s.Fields[5], 10, 32)
			if err != nil {
				return fmt.Errorf("ST decode variation error: %s", s.Fields[5])
			} else {
				s.CoreST.HrzlDimofRegioninM = uint32(i)
				s.CoreST.HrzlDimofRegioninMValidity = true
			}

		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			i, err := strconv.ParseUint(s.Fields[6], 10, 32)
			if err != nil {
				return fmt.Errorf("ST decode variation error: %s", s.Fields[6])
			} else {
				s.CoreST.VrtlDimofRegioninM = uint32(i)
				s.CoreST.VrtlDimofRegioninMValidity = true
			}

		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			i, err := strconv.ParseFloat(s.Fields[7], 64)
			if err != nil {
				return fmt.Errorf("ST decode variation error: %s", s.Fields[7])
			} else {
				s.CoreST.PfaMultiplyingFactor = float64(i)
				s.CoreST.PfaMultiplyingFactorValidity = true
			}

		}
	}

	if len(s.Fields) == 8 {
		return nil
	} else {
		if s.Fields[8] != "" {
			i, err := strconv.ParseUint(s.Fields[8], 10, 32)
			if err != nil {
				return fmt.Errorf("ST decode variation error: %s", s.Fields[8])
			} else {
				s.CoreST.RegionShapeFlag = uint32(i)
				s.CoreST.RegionShapeFlagValidity = true
			}

		}
	}

	return nil
}

func (s *ST) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixST {
		err := fmt.Errorf("Sentence format %s is not a ST sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.TimeInSecTillNewPfaPersistsValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreST.TimeInSecTillNewPfaPersists), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreST.TimeInSecTillNewPfaPersists), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.CenterOfPfaWtoEinMValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatInt(int64(s.CoreST.CenterOfPfaWtoEinM), 10)

		} else {
			Raw = Raw + "," + strconv.FormatInt(int64(s.CoreST.CenterOfPfaWtoEinM), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.CenterOfPfaNtoSinMValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatInt(int64(s.CoreST.CenterOfPfaNtoSinM), 10)

		} else {
			Raw = Raw + "," + strconv.FormatInt(int64(s.CoreST.CenterOfPfaNtoSinM), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.TrackLocationWtoEinDegValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreST.TrackLocationWtoEinDeg, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreST.TrackLocationWtoEinDeg, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.TrackLocationNtoSinDegValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreST.TrackLocationNtoSinDeg, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreST.TrackLocationNtoSinDeg, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.HrzlDimofRegioninMValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreST.HrzlDimofRegioninM), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreST.HrzlDimofRegioninM), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.VrtlDimofRegioninMValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreST.VrtlDimofRegioninM), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreST.VrtlDimofRegioninM), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.PfaMultiplyingFactorValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreST.PfaMultiplyingFactor, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreST.PfaMultiplyingFactor, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.RegionShapeFlagValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreST.RegionShapeFlag), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreST.RegionShapeFlag), 10)
		}

	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
