// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixTLL prefix
	PrefixTLL = "TLL"
)

// TLL represents fix data.
type CoreTLL struct {
	TargetNumber uint8

	TargetNumberValidity bool

	Latitude float64

	LatitudeValidity bool

	LatitudeDirection string

	LatitudeDirectionValidity bool

	Longitude float64

	LongitudeValidity bool

	LongitudeDirection string

	LongitudeDirectionValidity bool

	Name string

	NameValidity bool

	UtcTime float64

	UtcTimeValidity bool

	Status string

	StatusValidity bool

	ReferenceTarget string

	ReferenceTargetValidity bool
}

type TLL struct {
	BaseSentence
	CoreTLL
}

func NewTLL(sentence BaseSentence) *TLL {
	s := new(TLL)
	s.BaseSentence = sentence

	s.TargetNumberValidity = false

	s.LatitudeValidity = false

	s.LatitudeDirectionValidity = false

	s.LongitudeValidity = false

	s.LongitudeDirectionValidity = false

	s.NameValidity = false

	s.UtcTimeValidity = false

	s.StatusValidity = false

	s.ReferenceTargetValidity = false

	return s
}

func (s *TLL) parse() error {
	var err error

	if s.Format != PrefixTLL {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixTLL)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseFloat(s.Fields[0], 64)
			if err != nil {
				return fmt.Errorf("TLL decode variation error: %s", s.Fields[0])
			} else {
				s.CoreTLL.Latitude = float64(i)
				s.CoreTLL.LatitudeValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			s.LatitudeDirection = s.Fields[1]
			s.LatitudeDirectionValidity = true
		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseFloat(s.Fields[2], 64)
			if err != nil {
				return fmt.Errorf("TLL decode variation error: %s", s.Fields[2])
			} else {
				s.CoreTLL.Longitude = float64(i)
				s.CoreTLL.LongitudeValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			s.LongitudeDirection = s.Fields[3]
			s.LongitudeDirectionValidity = true
		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			s.Name = s.Fields[4]
			s.NameValidity = true
		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			i, err := strconv.ParseFloat(s.Fields[5], 64)
			if err != nil {
				return fmt.Errorf("TLL decode variation error: %s", s.Fields[5])
			} else {
				s.CoreTLL.UtcTime = float64(i)
				s.CoreTLL.UtcTimeValidity = true
			}

		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			s.Status = s.Fields[6]
			s.StatusValidity = true
		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			s.ReferenceTarget = s.Fields[7]
			s.ReferenceTargetValidity = true
		}
	}

	return nil
}

func (s *TLL) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixTLL {
		err := fmt.Errorf("Sentence format %s is not a TLL sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.LatitudeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreTLL.Latitude, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreTLL.Latitude, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LatitudeDirectionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTLL.LatitudeDirection

		} else {
			Raw = Raw + "," + s.CoreTLL.LatitudeDirection
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LongitudeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreTLL.Longitude, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreTLL.Longitude, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LongitudeDirectionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTLL.LongitudeDirection

		} else {
			Raw = Raw + "," + s.CoreTLL.LongitudeDirection
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.NameValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTLL.Name

		} else {
			Raw = Raw + "," + s.CoreTLL.Name
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.UtcTimeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreTLL.UtcTime, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreTLL.UtcTime, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StatusValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTLL.Status

		} else {
			Raw = Raw + "," + s.CoreTLL.Status
		}
	}

	if s.ReferenceTargetValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTLL.ReferenceTarget

		} else {
			Raw = Raw + "," + s.CoreTLL.ReferenceTarget
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
