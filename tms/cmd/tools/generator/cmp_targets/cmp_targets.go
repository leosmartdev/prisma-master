// +build ignore

// cmp_targets generates a file with functions that compare different value by name.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"prisma/tms/rule"
)

//go:generate go run cmp_targets.go --file $GOPATH/src/prisma/tms/rule/cmp_targets_gen.go

var tplFunc = `
func comp{{NAME}}Value(val, valOrigin interface{}) (bool, error) {
	switch defVal := val.(type) {
	// if specificValue is zero then we don't measure with our target
	case int32:
		if resVal, ok := valOrigin.(int32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal {{OPERATOR}} defVal, nil
		}
	case int64:
		if resVal, ok := valOrigin.(int64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal {{OPERATOR}} defVal, nil
		}
	case uint32:
		if resVal, ok := valOrigin.(uint32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal {{OPERATOR}} defVal, nil
		}
	case uint64:
		if resVal, ok := valOrigin.(uint64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal {{OPERATOR}} defVal, nil
		}
	case float32:
		if resVal, ok := valOrigin.(float32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal {{OPERATOR}} defVal, nil
		}
	case float64:
		if resVal, ok := valOrigin.(float64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal {{OPERATOR}} defVal, nil
		}
	case string:
		if resVal, ok := valOrigin.(string); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal {{OPERATOR}} defVal, nil
		}
	case *google_protobuf1.DoubleValue:
		if resVal, ok := valOrigin.(*google_protobuf1.DoubleValue); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			if resVal == nil || defVal == nil {
				return false, nil
			}
			return resVal.Value {{OPERATOR}} defVal.Value, nil
		}
	default:
		return false, errors.New("unknown type")
	}
}
`

type operation struct {
	operator string
	name     string
}

var typesCompare = map[rule.Rule_Operation]operation{
	rule.Rule_EQUAL: {
		"==",
		"Equal",
	},
	rule.Rule_GREATER: {
		">",
		"Greater",
	},
	rule.Rule_GREATER_EQUAL: {
		">=",
		"GreaterEqual",
	},
	rule.Rule_LESSER: {
		"<",
		"Lesser",
	},
	rule.Rule_LESSER_EQUAL: {
		"<=",
		"LesserEqual",
	},
}

func main() {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "// prisma/tms/generator/rule/cmp_targets.go\n")
	fmt.Fprintf(&bb, "// GENERATED BY THE FILE ABOVE; DO NOT EDIT\n\n")
	fmt.Fprintf(&bb, "package rule\n\n")
	fmt.Fprintf(&bb, `import (`)
	fmt.Fprintf(&bb, `"errors"`)
	fmt.Fprintf(&bb, "\n")
	fmt.Fprintf(&bb, `google_protobuf1 "github.com/golang/protobuf/ptypes/wrappers"`)
	fmt.Fprintf(&bb, "\n)\n")
	fileOut := flag.String("file", "cmp_targets_gen.go", "output file")
	flag.Parse()
	for _, op := range typesCompare {
		fnc := strings.Replace(tplFunc, "{{NAME}}", op.name, -1)
		fnc = strings.Replace(fnc, "{{OPERATOR}}", op.operator, -1)
		fmt.Fprintf(&bb, fnc)
	}

	if err := ioutil.WriteFile(*fileOut, bb.Bytes(), 0644); err != nil {
		os.Exit(1)
	}
}
