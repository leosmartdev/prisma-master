// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixBCG prefix
	PrefixBCG = "BCG"
)

// BCG represents fix data.
type CoreBCG struct {
	StationID string

	StationIDValidity bool

	RxChannelANumber uint32

	RxChannelANumberValidity bool

	RxChannelBNumber uint32

	RxChannelBNumberValidity bool

	TxChannelANumber uint32

	TxChannelANumberValidity bool

	TxChannelBNumber uint32

	TxChannelBNumberValidity bool

	PowerA uint32

	PowerAValidity bool

	PowerB uint32

	PowerBValidity bool

	VdlMsgRetries uint32

	VdlMsgRetriesValidity bool

	VdlMsgRepeatIndicator uint32

	VdlMsgRepeatIndicatorValidity bool

	RatdmaAccess uint32

	RatdmaAccessValidity bool

	UtcSourceSelection string

	UtcSourceSelectionValidity bool

	AdsInterval uint32

	AdsIntervalValidity bool

	AssignedTalker string

	AssignedTalkerValidity bool

	Status string

	StatusValidity bool
}

type BCG struct {
	BaseSentence
	CoreBCG
}

func NewBCG(sentence BaseSentence) *BCG {
	s := new(BCG)
	s.BaseSentence = sentence

	s.StationIDValidity = false

	s.RxChannelANumberValidity = false

	s.RxChannelBNumberValidity = false

	s.TxChannelANumberValidity = false

	s.TxChannelBNumberValidity = false

	s.PowerAValidity = false

	s.PowerBValidity = false

	s.VdlMsgRetriesValidity = false

	s.VdlMsgRepeatIndicatorValidity = false

	s.RatdmaAccessValidity = false

	s.UtcSourceSelectionValidity = false

	s.AdsIntervalValidity = false

	s.AssignedTalkerValidity = false

	s.StatusValidity = false

	return s
}

func (s *BCG) parse() error {
	var err error

	if s.Format != PrefixBCG {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixBCG)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			s.StationID = s.Fields[0]
			s.StationIDValidity = true
		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseUint(s.Fields[1], 10, 32)
			if err != nil {
				return fmt.Errorf("BCG decode variation error: %s", s.Fields[1])
			} else {
				s.CoreBCG.RxChannelANumber = uint32(i)
				s.CoreBCG.RxChannelANumberValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseUint(s.Fields[2], 10, 32)
			if err != nil {
				return fmt.Errorf("BCG decode variation error: %s", s.Fields[2])
			} else {
				s.CoreBCG.RxChannelBNumber = uint32(i)
				s.CoreBCG.RxChannelBNumberValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			i, err := strconv.ParseUint(s.Fields[3], 10, 32)
			if err != nil {
				return fmt.Errorf("BCG decode variation error: %s", s.Fields[3])
			} else {
				s.CoreBCG.TxChannelANumber = uint32(i)
				s.CoreBCG.TxChannelANumberValidity = true
			}

		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseUint(s.Fields[4], 10, 32)
			if err != nil {
				return fmt.Errorf("BCG decode variation error: %s", s.Fields[4])
			} else {
				s.CoreBCG.TxChannelBNumber = uint32(i)
				s.CoreBCG.TxChannelBNumberValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			i, err := strconv.ParseUint(s.Fields[5], 10, 32)
			if err != nil {
				return fmt.Errorf("BCG decode variation error: %s", s.Fields[5])
			} else {
				s.CoreBCG.PowerA = uint32(i)
				s.CoreBCG.PowerAValidity = true
			}

		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			i, err := strconv.ParseUint(s.Fields[6], 10, 32)
			if err != nil {
				return fmt.Errorf("BCG decode variation error: %s", s.Fields[6])
			} else {
				s.CoreBCG.PowerB = uint32(i)
				s.CoreBCG.PowerBValidity = true
			}

		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			i, err := strconv.ParseUint(s.Fields[7], 10, 32)
			if err != nil {
				return fmt.Errorf("BCG decode variation error: %s", s.Fields[7])
			} else {
				s.CoreBCG.VdlMsgRetries = uint32(i)
				s.CoreBCG.VdlMsgRetriesValidity = true
			}

		}
	}

	if len(s.Fields) == 8 {
		return nil
	} else {
		if s.Fields[8] != "" {
			i, err := strconv.ParseUint(s.Fields[8], 10, 32)
			if err != nil {
				return fmt.Errorf("BCG decode variation error: %s", s.Fields[8])
			} else {
				s.CoreBCG.VdlMsgRepeatIndicator = uint32(i)
				s.CoreBCG.VdlMsgRepeatIndicatorValidity = true
			}

		}
	}

	if len(s.Fields) == 9 {
		return nil
	} else {
		if s.Fields[9] != "" {
			i, err := strconv.ParseUint(s.Fields[9], 10, 32)
			if err != nil {
				return fmt.Errorf("BCG decode variation error: %s", s.Fields[9])
			} else {
				s.CoreBCG.RatdmaAccess = uint32(i)
				s.CoreBCG.RatdmaAccessValidity = true
			}

		}
	}

	if len(s.Fields) == 10 {
		return nil
	} else {
		if s.Fields[10] != "" {
			s.UtcSourceSelection = s.Fields[10]
			s.UtcSourceSelectionValidity = true
		}
	}

	if len(s.Fields) == 11 {
		return nil
	} else {
		if s.Fields[11] != "" {
			i, err := strconv.ParseUint(s.Fields[11], 10, 32)
			if err != nil {
				return fmt.Errorf("BCG decode variation error: %s", s.Fields[11])
			} else {
				s.CoreBCG.AdsInterval = uint32(i)
				s.CoreBCG.AdsIntervalValidity = true
			}

		}
	}

	if len(s.Fields) == 12 {
		return nil
	} else {
		if s.Fields[12] != "" {
			s.AssignedTalker = s.Fields[12]
			s.AssignedTalkerValidity = true
		}
	}

	if len(s.Fields) == 13 {
		return nil
	} else {
		if s.Fields[13] != "" {
			s.Status = s.Fields[13]
			s.StatusValidity = true
		}
	}

	return nil
}

func (s *BCG) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixBCG {
		err := fmt.Errorf("Sentence format %s is not a BCG sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.StationIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreBCG.StationID

		} else {
			Raw = Raw + "," + s.CoreBCG.StationID
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.RxChannelANumberValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.RxChannelANumber), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.RxChannelANumber), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.RxChannelBNumberValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.RxChannelBNumber), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.RxChannelBNumber), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.TxChannelANumberValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.TxChannelANumber), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.TxChannelANumber), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.TxChannelBNumberValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.TxChannelBNumber), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.TxChannelBNumber), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.PowerAValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.PowerA), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.PowerA), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.PowerBValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.PowerB), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.PowerB), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.VdlMsgRetriesValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.VdlMsgRetries), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.VdlMsgRetries), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.VdlMsgRepeatIndicatorValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.VdlMsgRepeatIndicator), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.VdlMsgRepeatIndicator), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.RatdmaAccessValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.RatdmaAccess), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.RatdmaAccess), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.UtcSourceSelectionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreBCG.UtcSourceSelection

		} else {
			Raw = Raw + "," + s.CoreBCG.UtcSourceSelection
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.AdsIntervalValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.AdsInterval), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBCG.AdsInterval), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.AssignedTalkerValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreBCG.AssignedTalker

		} else {
			Raw = Raw + "," + s.CoreBCG.AssignedTalker
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StatusValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreBCG.Status

		} else {
			Raw = Raw + "," + s.CoreBCG.Status
		}
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
