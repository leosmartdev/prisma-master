// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixACM prefix
	PrefixACM = "ACM"
)

// ACM represents fix data.
type CoreACM struct {
	Destination1ID uint32

	Destination1IDValidity bool

	Destination2ID uint32

	Destination2IDValidity bool

	ChannelANumber uint32

	ChannelANumberValidity bool

	ChannelABandwidth uint32

	ChannelABandwidthValidity bool

	ChannelBNumber uint32

	ChannelBNumberValidity bool

	ChannelBBandwidth uint32

	ChannelBBandwidthValidity bool

	Transmit uint32

	TransmitValidity bool

	Power uint32

	PowerValidity bool

	StationChannel uint32

	StationChannelValidity bool

	TransitionZoneSize uint32

	TransitionZoneSizeValidity bool

	Status string

	StatusValidity bool
}

type ACM struct {
	BaseSentence
	CoreACM
}

func NewACM(sentence BaseSentence) *ACM {
	s := new(ACM)
	s.BaseSentence = sentence

	s.Destination1IDValidity = false

	s.Destination2IDValidity = false

	s.ChannelANumberValidity = false

	s.ChannelABandwidthValidity = false

	s.ChannelBNumberValidity = false

	s.ChannelBBandwidthValidity = false

	s.TransmitValidity = false

	s.PowerValidity = false

	s.StationChannelValidity = false

	s.TransitionZoneSizeValidity = false

	s.StatusValidity = false

	return s
}

func (s *ACM) parse() error {
	var err error

	if s.Format != PrefixACM {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixACM)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseUint(s.Fields[0], 10, 32)
			if err != nil {
				return fmt.Errorf("ACM decode variation error: %s", s.Fields[0])
			} else {
				s.CoreACM.Destination1ID = uint32(i)
				s.CoreACM.Destination1IDValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseUint(s.Fields[1], 10, 32)
			if err != nil {
				return fmt.Errorf("ACM decode variation error: %s", s.Fields[1])
			} else {
				s.CoreACM.Destination2ID = uint32(i)
				s.CoreACM.Destination2IDValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseUint(s.Fields[2], 10, 32)
			if err != nil {
				return fmt.Errorf("ACM decode variation error: %s", s.Fields[2])
			} else {
				s.CoreACM.ChannelANumber = uint32(i)
				s.CoreACM.ChannelANumberValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			i, err := strconv.ParseUint(s.Fields[3], 10, 32)
			if err != nil {
				return fmt.Errorf("ACM decode variation error: %s", s.Fields[3])
			} else {
				s.CoreACM.ChannelABandwidth = uint32(i)
				s.CoreACM.ChannelABandwidthValidity = true
			}

		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseUint(s.Fields[4], 10, 32)
			if err != nil {
				return fmt.Errorf("ACM decode variation error: %s", s.Fields[4])
			} else {
				s.CoreACM.ChannelBNumber = uint32(i)
				s.CoreACM.ChannelBNumberValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			i, err := strconv.ParseUint(s.Fields[5], 10, 32)
			if err != nil {
				return fmt.Errorf("ACM decode variation error: %s", s.Fields[5])
			} else {
				s.CoreACM.ChannelBBandwidth = uint32(i)
				s.CoreACM.ChannelBBandwidthValidity = true
			}

		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			i, err := strconv.ParseUint(s.Fields[6], 10, 32)
			if err != nil {
				return fmt.Errorf("ACM decode variation error: %s", s.Fields[6])
			} else {
				s.CoreACM.Transmit = uint32(i)
				s.CoreACM.TransmitValidity = true
			}

		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			i, err := strconv.ParseUint(s.Fields[7], 10, 32)
			if err != nil {
				return fmt.Errorf("ACM decode variation error: %s", s.Fields[7])
			} else {
				s.CoreACM.Power = uint32(i)
				s.CoreACM.PowerValidity = true
			}

		}
	}

	if len(s.Fields) == 8 {
		return nil
	} else {
		if s.Fields[8] != "" {
			i, err := strconv.ParseUint(s.Fields[8], 10, 32)
			if err != nil {
				return fmt.Errorf("ACM decode variation error: %s", s.Fields[8])
			} else {
				s.CoreACM.StationChannel = uint32(i)
				s.CoreACM.StationChannelValidity = true
			}

		}
	}

	if len(s.Fields) == 9 {
		return nil
	} else {
		if s.Fields[9] != "" {
			i, err := strconv.ParseUint(s.Fields[9], 10, 32)
			if err != nil {
				return fmt.Errorf("ACM decode variation error: %s", s.Fields[9])
			} else {
				s.CoreACM.TransitionZoneSize = uint32(i)
				s.CoreACM.TransitionZoneSizeValidity = true
			}

		}
	}

	if len(s.Fields) == 10 {
		return nil
	} else {
		if s.Fields[10] != "" {
			s.Status = s.Fields[10]
			s.StatusValidity = true
		}
	}

	return nil
}

func (s *ACM) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixACM {
		err := fmt.Errorf("Sentence format %s is not a ACM sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.Destination1IDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.Destination1ID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.Destination1ID), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.Destination2IDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.Destination2ID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.Destination2ID), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ChannelANumberValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.ChannelANumber), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.ChannelANumber), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ChannelABandwidthValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.ChannelABandwidth), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.ChannelABandwidth), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ChannelBNumberValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.ChannelBNumber), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.ChannelBNumber), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ChannelBBandwidthValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.ChannelBBandwidth), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.ChannelBBandwidth), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.TransmitValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.Transmit), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.Transmit), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.PowerValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.Power), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.Power), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StationChannelValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.StationChannel), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.StationChannel), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.TransitionZoneSizeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.TransitionZoneSize), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreACM.TransitionZoneSize), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StatusValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreACM.Status

		} else {
			Raw = Raw + "," + s.CoreACM.Status
		}
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
