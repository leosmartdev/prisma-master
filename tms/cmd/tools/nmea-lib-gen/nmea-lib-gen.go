// nmea-lib-gen generates structures which parse nmea sentences.
package main

// this program should build then run form the typedef.go file as bellow
// ./parse_file -file=/Path/to/sentence/definition.go

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"
)

var (
	File = flag.String("file", "", "-file=/path/to/nmea_typedef.json file path must be set like that")
)

type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

type jsentence struct {
	Name       string
	Formatter  string
	FieldCount int
	Fields     []field
	RecordSize int
}

type field struct {
	Name     string
	Type     string
	Encbsize int // bits sizes for every variable only used with M1371
}

func jsonParse(filename string) []jsentence {

	file, e := ioutil.ReadFile(filename)
	if e != nil {
		fmt.Printf("File error: %v\n", e)
		os.Exit(1)
	}

	var jsontype []jsentence
	json.Unmarshal(file, &jsontype)

	return jsontype
}

func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func main() {

	log.SetFlags(0)
	log.SetPrefix("generator: ")

	flag.Parse()

	if len(*File) == 0 {
		fmt.Println("Please mention the nmea_typedef.json file")
		os.Exit(3)
	}

	SentencesArray := jsonParse(*File)

	var pg Generator

	pg.Printf("// Code generated by parse_nmea; DO NOT EDIT \n")
	pg.Printf("package nmea\n")
	pg.Printf("import \"fmt\"\n")
	pg.Printf("\n")
	pg.Printf("// Parse parses the given string into the correct sentence type.\n")
	pg.Printf("func ParseArray(s []string) (Sentence, error, int) {\n")
	pg.Printf("sentence := BaseSentence{}\n")
	pg.Printf("if err := sentence.parse(s[0]); err != nil { \n return nil, err,-1 \n  }")

	for _, SentenceStruct := range SentencesArray {

		if !strings.Contains(SentenceStruct.Name, "M1371") {

			var g Generator

			if SentenceStruct.Name != "VDMO" {
				pg.Printf(Parse, SentenceStruct.Name)
				pg.Printf("\n")
			}

			g.Printf("// Code generated by parse_nmea; DO NOT EDIT \n")
			g.Printf("package nmea\n")
			g.Printf("import \"fmt\"\n")
			g.Printf("import \"strings\"\n")

		loop:
			for _, t := range SentenceStruct.Fields {
				if t.Type == "double" || t.Type == "uint32" || t.Type == "int32" || t.Type == "int" {
					fmt.Println("true")
					g.Printf("import \"strconv\"\n")
					break loop
				}
			}

			if SentenceStruct.Name == "VDMO" {
				g.Printf(newConstantVDM_O)
			} else {
				g.Printf(newConstant, SentenceStruct.Name)
			} // writes the Sentence constant prefixXXX = Sentence format

			g.Printf("\n")
			g.Printf(newStructure, SentenceStruct.Name, "", "Core") //writes the first line of the sentence definition

			for i := 0; i < SentenceStruct.FieldCount; i++ {

				if SentenceStruct.Fields[i].Name != "Format" && SentenceStruct.Fields[i].Name != "Sos" && SentenceStruct.Fields[i].Name != "Talker" && SentenceStruct.Fields[i].Name != "Checksum" {

					if SentenceStruct.Fields[i].Type == "double" {
						g.Printf(newNMEAFieldDef, SentenceStruct.Fields[i].Name, "float64")
					} else if SentenceStruct.Fields[i].Type == "unknown" {
						g.Printf(newNMEAFieldDef, SentenceStruct.Fields[i].Name, "string //Supposed to be Unknown")
					} else {
						g.Printf(newNMEAFieldDef, SentenceStruct.Fields[i].Name, SentenceStruct.Fields[i].Type)
					}

				}

			}
			g.Printf("}") // close the sentence definition
			g.Printf("\n")
			g.Printf(NewNnmeaStruct, SentenceStruct.Name, "BaseSentence")

			g.Printf("\n")
			g.Printf(newSentence, SentenceStruct.Name, "BaseSentence")
			for i := 0; i < SentenceStruct.FieldCount; i++ {
				if SentenceStruct.Fields[i].Name != "Format" && SentenceStruct.Fields[i].Name != "Sos" && SentenceStruct.Fields[i].Name != "Talker" && SentenceStruct.Fields[i].Name != "Checksum" {
					g.Printf(ValidityInitialize, SentenceStruct.Fields[i].Name) // initialize validity field to false in the sentences constructors
				}
			}
			g.Printf("return s\n")
			g.Printf("}")

			g.Printf("\n")

			g.Printf("\n")
			if SentenceStruct.Name == "VDMO" {
				g.Printf(NewParserVDM_O, SentenceStruct.Name)
			} else {
				g.Printf(newParser, SentenceStruct.Name)
			}

			g.Printf("\n")
			x := 0
			for i := 0; i < SentenceStruct.FieldCount; i++ {

				if SentenceStruct.Fields[i].Name != "Format" && SentenceStruct.Fields[i].Name != "Sos" && SentenceStruct.Fields[i].Name != "Talker" && SentenceStruct.Fields[i].Name != "Checksum" {

					if SentenceStruct.Fields[i].Type == "double" {
						g.Printf(newTypefield, SentenceStruct.Fields[i].Name, x, SentenceStruct.Name, "Float", ", 64", "float64")
						x++
					}
					if SentenceStruct.Fields[i].Type == "int32" {
						g.Printf(newTypefield, SentenceStruct.Fields[i].Name, x, SentenceStruct.Name, "Int", ", 10, 32", "int32")
						x++
					}
					if SentenceStruct.Fields[i].Type == "int" {
						g.Printf(newTypefield, SentenceStruct.Fields[i].Name, x, SentenceStruct.Name, "Int", ", 10, 64", "int")
						x++
					}
					if SentenceStruct.Fields[i].Type == "uint32" {
						g.Printf(newTypefield, SentenceStruct.Fields[i].Name, x, SentenceStruct.Name, "Uint", ", 10, 32", "uint32")
						x++
					}
					if SentenceStruct.Fields[i].Type == "string" {
						g.Printf(newField, SentenceStruct.Fields[i].Name, x)
						x++
					}
				}
			}

			g.Printf("\n")
			g.Printf("return nil")
			g.Printf("\n")
			g.Printf("}")

			g.Printf("\n")
			// start of EncodeNMEA methods generation
			if SentenceStruct.Name == "VDMO" {
				g.Printf(NewEncodeNMEA_VDMO, SentenceStruct.Name)
			} else {
				g.Printf(NewEncodeNMEA, SentenceStruct.Name)
			}

			for i := 0; i < SentenceStruct.FieldCount; i++ {
				if SentenceStruct.Fields[i].Name != "Format" && SentenceStruct.Fields[i].Name != "Sos" && SentenceStruct.Fields[i].Name != "Talker" && SentenceStruct.Fields[i].Name != "Checksum" {

					if i == SentenceStruct.FieldCount-2 {
						if SentenceStruct.Fields[i].Type == "double" {
							g.Printf(FieldEncodeNMEA_double_Last, SentenceStruct.Fields[i].Name, SentenceStruct.Name)
						}
						if SentenceStruct.Fields[i].Type == "int32" {
							g.Printf(FieldEncodeNMEA_int32_Last, SentenceStruct.Fields[i].Name, SentenceStruct.Name)
						}
						if SentenceStruct.Fields[i].Type == "int" {
							g.Printf(FieldEncodeNMEA_int_Last, SentenceStruct.Fields[i].Name, SentenceStruct.Name)
						}
						if SentenceStruct.Fields[i].Type == "uint32" {
							g.Printf(FieldEncodeNMEA_uint32_Last, SentenceStruct.Fields[i].Name, SentenceStruct.Name)
						}
						if SentenceStruct.Fields[i].Type == "string" {
							g.Printf(FieldEncodeNMEA_string_Last, SentenceStruct.Fields[i].Name, SentenceStruct.Name)
						}

					} else {
						if SentenceStruct.Fields[i].Type == "double" {
							g.Printf(FieldEncodeNMEA_double, SentenceStruct.Fields[i].Name, SentenceStruct.Name)
						}
						if SentenceStruct.Fields[i].Type == "int32" {
							g.Printf(FieldEncodeNMEA_int32, SentenceStruct.Fields[i].Name, SentenceStruct.Name)
						}
						if SentenceStruct.Fields[i].Type == "int" {
							g.Printf(FieldEncodeNMEA_int, SentenceStruct.Fields[i].Name, SentenceStruct.Name)
						}
						if SentenceStruct.Fields[i].Type == "uint32" {
							g.Printf(FieldEncodeNMEA_uint32, SentenceStruct.Fields[i].Name, SentenceStruct.Name)
						}
						if SentenceStruct.Fields[i].Type == "string" {
							g.Printf(FieldEncodeNMEA_string, SentenceStruct.Fields[i].Name, SentenceStruct.Name)
						}
					} // end of else condition

				} //end of if condition for format, Sos ...
			} //end of for loop for EncodeNMEA methods generator

			g.Printf(EEncodeNMEA)
			src := g.format()

			outputName := fmt.Sprintf("%s_parser_gen.go", SentenceStruct.Name)

			err := ioutil.WriteFile(outputName, src, 0644)
			if err != nil {
				log.Fatalf("writing output: %s", err)
			}

		} //end of if condition for VDM_O
	}

	for _, SentenceStruct := range SentencesArray {

		if SentenceStruct.Name == "VDMO" {
			pg.Printf(NewParseVDM_O)
		}
	}

	for _, SentenceStruct := range SentencesArray {

		if strings.Contains(SentenceStruct.Name, "M1371") {

			var g Generator

			if SentenceStruct.Name == "M137124B" {

				sen_id, _ := strconv.ParseInt(strings.TrimSuffix(strings.TrimPrefix(SentenceStruct.Name, "M1371"), "B"), 10, 8)
				pg.Printf(ParseVDM_O, SentenceStruct.Name, sen_id, " && BitsToInt(38, 39, []byte(VD.EncapData)) == 1")

			} else if SentenceStruct.Name == "M137124A" {

				sen_id, _ := strconv.ParseInt(strings.TrimSuffix(strings.TrimPrefix(SentenceStruct.Name, "M1371"), "A"), 10, 8)
				pg.Printf(ParseVDM_O, SentenceStruct.Name, sen_id, " && BitsToInt(38, 39, []byte(VD.EncapData)) == 0")

			} else {

				sen_id, _ := strconv.ParseInt(strings.TrimPrefix(SentenceStruct.Name, "M1371"), 10, 8)
				pg.Printf(ParseVDM_O, SentenceStruct.Name, sen_id, "")

			}

			g.Printf("// Code generated by parse_nmea; DO NOT EDIT \n")
			g.Printf("package nmea\n")
			g.Printf("import \"fmt\"\n")
			g.Printf("import \"strconv\"\n")
			g.Printf("import \"strings\"\n")

			g.Printf("\n")
			g.Printf(newStructure, SentenceStruct.Name, "", "Core")
			g.Printf("\n")

			for i := 0; i < SentenceStruct.FieldCount; i++ {

				if SentenceStruct.Fields[i].Type == "double" {

					g.Printf(newM1371FieldDef, SentenceStruct.Fields[i].Name, "float64")

				} else if SentenceStruct.Fields[i].Type == "unknown" {

					g.Printf(newM1371FieldDef, SentenceStruct.Fields[i].Name, "uint32 //Supposed to be Unknown")

				} else {
					g.Printf(newM1371FieldDef, SentenceStruct.Fields[i].Name, SentenceStruct.Fields[i].Type)
				}

			} // end of type def loop

			g.Printf("}") // close the sentence definition of M1371 Sentence
			g.Printf(NewNnmeaStruct, SentenceStruct.Name, "VDMO")

			g.Printf("\n")
			g.Printf(newSentence, SentenceStruct.Name, "VDMO")
			//
			g.Printf("return s\n")
			g.Printf("}")
			g.Printf("\n")
			g.Printf("\n")
			var x int = 0 // lenght of data bits for an AIS sentence
			for i := 0; i < SentenceStruct.FieldCount; i++ {
				x = x + SentenceStruct.Fields[i].Encbsize
			}

			if SentenceStruct.Name == "M137124B" {

				sen_id, _ := strconv.ParseInt(strings.TrimSuffix(strings.TrimPrefix(SentenceStruct.Name, "M1371"), "B"), 10, 8)
				g.Printf(NewParserM1371, SentenceStruct.Name, sen_id, x)

			} else if SentenceStruct.Name == "M137124A" {

				sen_id, _ := strconv.ParseInt(strings.TrimSuffix(strings.TrimPrefix(SentenceStruct.Name, "M1371"), "A"), 10, 8)
				g.Printf(NewParserM1371, SentenceStruct.Name, sen_id, x)

			} else {

				sen_id, _ := strconv.ParseInt(strings.TrimPrefix(SentenceStruct.Name, "M1371"), 10, 8)
				g.Printf(NewParserM1371, SentenceStruct.Name, sen_id, x)

			}

			x = 5
			y := 0
			var end string
			for i := 1; i < SentenceStruct.FieldCount; i++ {

				if (i - SentenceStruct.FieldCount) == -1 {
					y = x + 1 // start for bits alocated for that field
					end = "6*(len(data)-1)"
				} else {
					y = x + 1                                   // start for bits alocated for that field
					x = (x + SentenceStruct.Fields[i].Encbsize) // end of bits allocated for that field
					end = strconv.Itoa(x)
				}

				if SentenceStruct.Fields[i].Type == "uint32" || SentenceStruct.Fields[i].Type == "unknown" {
					g.Printf(newFieldM1371, SentenceStruct.Fields[i].Name, "BitsToInt("+strconv.Itoa(y)+","+end+", data)", SentenceStruct.Name)
				}
				if SentenceStruct.Fields[i].Type == "string" {
					g.Printf(newFieldM1371, SentenceStruct.Fields[i].Name, "BitsToString("+strconv.Itoa(y)+","+end+", data)", SentenceStruct.Name)

				}
				if SentenceStruct.Fields[i].Type == "int" {
					g.Printf(newFieldM1371, SentenceStruct.Fields[i].Name, "int(BitsToInt("+strconv.Itoa(y)+","+end+", data))", SentenceStruct.Name)

				}
				if SentenceStruct.Fields[i].Type == "int32" {
					g.Printf(newFieldM1371, SentenceStruct.Fields[i].Name, "int32(BitsToInt("+strconv.Itoa(y)+","+end+", data))", SentenceStruct.Name)

				}
				if SentenceStruct.Fields[i].Type == "double" {
					if SentenceStruct.Fields[i].Name == "Longitude" {
						g.Printf(newFieldM1371, SentenceStruct.Fields[i].Name, "(float64(int32(BitsToInt("+strconv.Itoa(y)+","+end+", data)) << 4))/ 16", SentenceStruct.Name)
					} else if SentenceStruct.Fields[i].Name == "Latitude" {
						g.Printf(newFieldM1371, SentenceStruct.Fields[i].Name, "(float64(int32(BitsToInt("+strconv.Itoa(y)+","+end+", data)) << 5))/ 32", SentenceStruct.Name)
					} else {
						g.Printf(newFieldM1371, SentenceStruct.Fields[i].Name, "float64(BitsToInt("+strconv.Itoa(y)+","+end+", data))", SentenceStruct.Name)
					}
				}
				if SentenceStruct.Fields[i].Type == "uint8" {
					g.Printf(newFieldM1371, SentenceStruct.Fields[i].Name, "uint8(BitsToInt("+strconv.Itoa(y)+","+end+", data))", SentenceStruct.Name)

				}
				if SentenceStruct.Fields[i].Type == "int8" {
					g.Printf(newFieldM1371, SentenceStruct.Fields[i].Name, "int8(BitsToInt("+strconv.Itoa(y)+","+end+", data))", SentenceStruct.Name)

				}
				if SentenceStruct.Fields[i].Type == "bool" {
					g.Printf(newFieldM1371, SentenceStruct.Fields[i].Name, "CbnBool("+strconv.Itoa(y)+", data)", SentenceStruct.Name)

				}

			} //end of for loop .parse() method

			g.Printf("\n")
			g.Printf("return nil")
			g.Printf("\n")
			g.Printf("}")
			g.Printf("\n")
			// start of EncodeAIS methods generation
			if SentenceStruct.Name == "M137124A" {
				id, _ := strconv.ParseInt(strings.TrimSuffix(strings.TrimPrefix(SentenceStruct.Name, "M1371"), "A"), 10, 8)
				g.Printf(NewEncodeAIS, SentenceStruct.Name, id)
			} else if SentenceStruct.Name == "M137124B" {
				id, _ := strconv.ParseInt(strings.TrimSuffix(strings.TrimPrefix(SentenceStruct.Name, "M1371"), "B"), 10, 8)
				g.Printf(NewEncodeAIS, SentenceStruct.Name, id)
			} else {
				id, _ := strconv.ParseInt(strings.TrimPrefix(SentenceStruct.Name, "M1371"), 10, 8)
				g.Printf(NewEncodeAIS, SentenceStruct.Name, id)
			}

			for i := 1; i < SentenceStruct.FieldCount; i++ {
				if SentenceStruct.Fields[i].Type == "string" {
					g.Printf(SfieldEncodeAIS, SentenceStruct.Fields[i].Name, SentenceStruct.Fields[i].Encbsize, SentenceStruct.Name)
				} else if SentenceStruct.Fields[i].Type == "bool" {
					g.Printf(BfieldEncodeAIS, SentenceStruct.Fields[i].Name)
				} else {
					g.Printf(FieldEncodeAIS, SentenceStruct.Fields[i].Name, SentenceStruct.Fields[i].Encbsize, SentenceStruct.Name)
				}
			} //end of Encode Method generation

			g.Printf(EEncodeAIS)

			src := g.format()

			outputName := fmt.Sprintf("%s_parser_gen.go", SentenceStruct.Name)

			err := ioutil.WriteFile(outputName, src, 0644)
			if err != nil {
				log.Fatalf("writing output: %s", err)
			}

		} //end of if condition for checking if the sentence if M1371 format

	} //end of for loop

	pg.Printf("\nreturn VD, nil, 0")
	pg.Printf("\n}") // end of VDM_O Parse generation

	pg.Printf("\n")
	pg.Printf(`err := fmt.Errorf("Sentence type '%%s%%s%%s' not implemented",sentence.SOS, sentence.Talker, sentence.Format)`)
	pg.Printf("\nreturn nil, err, -1")
	pg.Printf("\n}")

	pg.Printf("\nfunc Parse(s string) (Sentence, error) {")
	pg.Printf("\nvar str = []string {s}")
	pg.Printf("\nSen,err,_:=ParseArray(str)")
	pg.Printf("\nreturn Sen, err")
	pg.Printf("\n}")

	src := pg.format()

	err := ioutil.WriteFile("Parse.go", src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)

	}

}

// generic building blocks of the sentence definitions, constructers, parsers and decoders.

const populatepb = `

if reflect.TypeOf(sentence).Elem().String() == "nmea.%[1]s" {

 senstruct := sentence.(*%[1]s)//(*nmea.%[1]s)

 base := senstruct.BaseSentence
 core := senstruct.Core%[1]s

 sen.OriginalString = base.Raw//"$GPGLL,3554.4456,N,528.9195,W,,,*5A"
 sen.Sos = base.SOS
 sen.Talker = base.Talker
 glll := pb.%[2]s{}
 err := copier.Copy(&glll, &core)
 if err != nil {
 	fmt.Println(err)
 }

 fmt.Println(base.Format)

 sen.%[2]s = &glll

}



`

const newConstant = `const (
	// Prefix%[1]s prefix
	Prefix%[1]s = "%[1]s"
)`

const newConstantVDM_O = ` const (
	// VDM prefix
	PrefixVDM = "VDM"
	// VDO prefix
	PrefixVDO = "VDO"
)`

const newStructure = `
// %[1]s represents fix data.
type %[3]s%[1]s struct {

	
`

const newNMEAFieldDef = ` 
	%[1]s %[2]s

	%[1]sValidity bool
`
const newM1371FieldDef = `
	%[1]s %[2]s
`

const newSentence = `func New%[1]s(sentence %[2]s) *%[1]s {
	s := new(%[1]s)
	s.%[2]s = sentence
	` //return } was here before validy initialization

const ValidityInitialize = `
	s.%[1]sValidity = false

`
const newParser = ` func (s *%[1]s) parse() error {
	var err error

	if s.Format != Prefix%[1]s {
		err = fmt.Errorf("%%s is not a %%s", s.Format, Prefix%[1]s)
		return err
	}
`
const NewParserVDM_O = `func (s *%[1]s) parse() error {
	var err error

	if s.Format != PrefixVDM && s.Format != PrefixVDO  {
		err = fmt.Errorf("%%s is not a %%s or %%s", s.Format, PrefixVDO, PrefixVDM)
		return err
	}
`
const NewParserM1371 = ` func (s *%[1]s) parse() error {
	var err error

	if  MessageType(s.EncapData) != %[2]d {
		err = fmt.Errorf("message %%d is not a %[1]s", MessageType(s.EncapData))
		return err
	}

	data := []byte(s.EncapData)

	//if len(data)*6 > %[3]d {
	//	err = fmt.Errorf("Message lenght is larger than it should be [%%d!=%[3]d]", len(data)*6)
	//	return err
	//}

	s.MessageID =  MessageType(s.EncapData)

`

const newLatLong = `
	s.%[1]s, err = NewLatLong(fmt.Sprintf("%%s %%s", s.Fields[%[3]d], s.Fields[%[3]d+1]))
	if err != nil {
		return fmt.Errorf("%[2]s decode %[1]s error: %%s", err)
	}
	
`
const newTypefield = `
	   if len(s.Fields) == %[2]d {
    	return nil	
	} else { 
		if s.Fields[%[2]d] != "" {
			i, err := strconv.Parse%[4]s(s.Fields[%[2]d] %[5]s)
			if err != nil {
				return fmt.Errorf("%[3]s decode variation error: %%s", s.Fields[%[2]d])
			} else { 
				s.Core%[3]s.%[1]s = %[6]s(i)
				s.Core%[3]s.%[1]sValidity = true
			  }
			
		}
			}
`
const newField = `
	if len(s.Fields) == %[2]d {
	return nil
} else {
	if s.Fields[%[2]d] != "" {
		s.%[1]s = s.Fields[%[2]d]
		s.%[1]sValidity = true
	} 
}
`
const newFieldM1371 = `

 s.Core%[3]s.%[1]s = %[2]s
	
`

const Parse = `
 if sentence.Format == Prefix%[1]s {
                %[1]s := New%[1]s(sentence)
                if err := %[1]s.parse();err!= nil {
                        return nil, err,-1
                }
                return %[1]s, nil, 1
        }


`

const NewParseVDM_O = `
 if sentence.Format == PrefixVDO || sentence.Format == PrefixVDM {
 	VD := NewVDMO(sentence)
		if err := VD.parse(); err != nil {
			return nil, err,-1
		}

	if VD.SentenceIndex != 1 {
			return nil, fmt.Errorf("error: sentence %%s is missing its 1st part", VD.Raw), -1
		}

    if VD.SentenceCount >= 2 && VD.SentenceIndex == 1 {
			for  i := 0; i < int(VD.SentenceCount); i++  {

			if len(s) == i {
					return nil, fmt.Errorf("error: index out of range. Parts of %%s are missing", VD.Raw), -1
				}
	
			if err := sentence.parse(s[i]); err != nil {
				return nil, err,-1
			}
			VDX := NewVDMO(sentence)
			if err := VDX.parse(); err != nil {
			return nil, err,-1
			}

			if VDX.SentenceCount != VD.SentenceCount {
				return nil, fmt.Errorf("Sentence count should be %%d in every sentence", VD.SentenceCount),-1
			}

			if int(VDX.SentenceIndex) != i+1  {
				return nil, fmt.Errorf("Sentence indeces are not coherent"),-1
			}
			
			if i != 0 {
					VD.EncapData = VD.EncapData + VDX.EncapData
 					VD.Raw = VD.Raw + "---" + VDX.Raw
 				}
			
			}
		}
 
`
const ParseVDM_O = `
	if MessageType(VD.EncapData) == %[2]d  %[3]s {
		%[1]s := New%[1]s(*VD)
			if err := %[1]s.parse(); err != nil {
			return nil, err, -1
		}
		return %[1]s, nil, int(VD.SentenceCount)
	}
`
const NewEncodeNMEA = `
func (s *%[1]s) Encode() (string, error) {
	var Raw string 

	if s.Format != Prefix%[1]s {
		err := fmt.Errorf("Sentence format %%s is not a %[1]s sentence", s.Format)
		return "", err
	}

	Raw = s.SOS+s.Talker+s.Format
`

const NewEncodeNMEA_VDMO = `
func (s *%[1]s) Encode() (string, error) {
	var Raw string 

	if s.Format != PrefixVDM && s.Format != PrefixVDO {
		err := fmt.Errorf("Sentence format %%s is not a VDM or VDO sentence", s.Format)
		return "", err
	}

	Raw = s.SOS+s.Talker+s.Format
`

const FieldEncodeNMEA_double = `
	
	if s.%[1]sValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw,",")){

			Raw = Raw + strconv.FormatFloat(s.Core%[2]s.%[1]s, 'f', -1, 64)

		} else { Raw = Raw + "," + strconv.FormatFloat(s.Core%[2]s.%[1]s, 'f', -1, 64) }

	} else if len(Raw)> len(strings.TrimSuffix(Raw, ",,")) {Raw = Raw + ","} else {Raw = Raw + ",,"}	

`
const FieldEncodeNMEA_double_Last = `
	
	if s.%[1]sValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw,",")){

			Raw = Raw + strconv.FormatFloat(s.Core%[2]s.%[1]s, 'f', -1, 64)

		} else { Raw = Raw + "," + strconv.FormatFloat(s.Core%[2]s.%[1]s, 'f', -1, 64) }

	}

`
const FieldEncodeNMEA_int32 = `

	if s.%[1]sValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw,",")){

			Raw = Raw + strconv.FormatInt(int64(s.Core%[2]s.%[1]s), 10)

		} else { Raw = Raw + "," + strconv.FormatInt(int64(s.Core%[2]s.%[1]s), 10) }

	} else if len(Raw)> len(strings.TrimSuffix(Raw, ",,")) {Raw = Raw + ","} else {Raw = Raw + ",,"}

`
const FieldEncodeNMEA_int32_Last = `

	if s.%[1]sValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw,",")){

			Raw = Raw + strconv.FormatInt(int64(s.Core%[2]s.%[1]s), 10)

		} else { Raw = Raw + "," + strconv.FormatInt(int64(s.Core%[2]s.%[1]s), 10) }

	}
`

const FieldEncodeNMEA_int = `

	if s.%[1]sValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw,",")){

			Raw = Raw + strconv.FormatInt(s.Core%[2]s.%[1]s, 10)

		} else { Raw = Raw + "," + strconv.FormatInt(s.Core%[2]s.%[1]s, 10) }

	} else if len(Raw)> len(strings.TrimSuffix(Raw, ",,")) {Raw = Raw + ","} else {Raw = Raw + ",,"}

`
const FieldEncodeNMEA_int_Last = `
	
	if s.%[1]sValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw,",")){

			Raw = Raw + strconv.FormatInt(s.Core%[2]s.%[1]s, 10)

		} else { Raw = Raw + "," + strconv.FormatInt(s.Core%[2]s.%[1]s, 10) }

	}
`

const FieldEncodeNMEA_uint32 = `

	if s.%[1]sValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw,",")){

			Raw = Raw + "," + strconv.FormatUint(uint64(s.Core%[2]s.%[1]s), 10)

		} else { Raw = Raw + "," + strconv.FormatUint(uint64(s.Core%[2]s.%[1]s), 10) }

	} else if len(Raw)> len(strings.TrimSuffix(Raw, ",,")) {Raw = Raw + ","} else {Raw = Raw + ",,"}

`

const FieldEncodeNMEA_uint32_Last = `

	if s.%[1]sValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw,",")){

			Raw = Raw + "," + strconv.FormatUint(uint64(s.Core%[2]s.%[1]s), 10)

		} else { Raw = Raw + "," + strconv.FormatUint(uint64(s.Core%[2]s.%[1]s), 10) }

	}
`

const FieldEncodeNMEA_string = `

	if s.%[1]sValidity == true {

			if len(Raw) > len(strings.TrimSuffix(Raw,",")){

				Raw = Raw + s.Core%[2]s.%[1]s

			} else {Raw = Raw + "," + s.Core%[2]s.%[1]s}

	} else if len(Raw)> len(strings.TrimSuffix(Raw, ",,")) {Raw = Raw + ","} else {Raw = Raw + ",,"}

`
const FieldEncodeNMEA_string_Last = `

	if s.%[1]sValidity == true {

			if len(Raw) > len(strings.TrimSuffix(Raw,",")){

				Raw = Raw + s.Core%[2]s.%[1]s

			} else {Raw = Raw + "," + s.Core%[2]s.%[1]s}
	}

`
const EEncodeNMEA = `

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
`

const NewEncodeAIS = `
func (s *%[1]s) Encode() (string, error) {
	var Raw string
	var Sbinary string

	if s.MessageID != %[2]d {
		err := fmt.Errorf("message %%d is not a %[1]s", s.MessageID)
		return "", err
	}

	Raw = s.SOS+s.Talker+s.Format+","

	if s.SentenceCountValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SentenceCount), 10)+ ","
	} else { Raw = Raw + "," }

	if s.SentenceIndexValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SentenceIndex), 10)+","
	} else { Raw = Raw + "," }

	if s.SeqMsgIDValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SeqMsgID),10)+","
	} else { Raw = Raw + ","}

	if s.ChannelValidity == true {
		Raw = Raw + s.Channel
	}
	
	str := strconv.FormatInt(int64(s.Core%[1]s.MessageID),2)
				for len(str)< 6 {
					str= "0"+ str
				}
	Sbinary = Sbinary + str
`
const FieldEncodeAIS = `

str = strconv.FormatInt(int64(s.Core%[3]s.%[1]s),2)
				for len(str)< %[2]d {
					str= "0"+ str
				}
	Sbinary = Sbinary + str

`
const BfieldEncodeAIS = `

	if s.%[1]s == true {
		str = "1"
		} else {str = "0"}

	Sbinary = Sbinary + str
`

const SfieldEncodeAIS = `
			if s.Core%[3]s.%[1]s != "" {
			str = ""

			for len([]byte(s.Core%[3]s.%[1]s))<%[2]d/6 {
				s.Core%[3]s.%[1]s = s.Core%[3]s.%[1]s +"@"
			
			}

			for _, n := range []byte(s.Core%[3]s.%[1]s) {
				if n >= 32 {
					n=n-64
				}
			name := strconv.FormatInt(int64(n),2)
				for len(name)<6{
				name = "0"+name
				}

			if len(name)>6 {
				if len(name)==8 {
					n=n-128
					name = strconv.FormatInt(int64(n),2)
				}
				if len(name)==7{
					n=n-64
					name = strconv.FormatInt(int64(n),2)
				}
			}

				str = str + name

			}

			Sbinary = Sbinary + str

		}

`
const EEncodeAIS = `
	field := strings.SplitN(Sbinary,"",len(Sbinary))

	var encdata = make([]string,int((len(Sbinary)+int(s.FillBits))/6))

	j:=0
	for i:=0;i<int((len(Sbinary)+int(s.FillBits))/6);i++ {

	if i == (int((len(Sbinary)+int(s.FillBits))/6) - 1) {
		for j < len(Sbinary){
			encdata[i] = encdata[i] + field[j]
			j = j + 1
		}
		for h:=0; h < int(s.FillBits); h++ {
			encdata[i]= encdata[i]+"0" // fill bits
		}
	} else { encdata[i]=field[j]+field[j+1]+field[j+2]+field[j+3]+field[j+4]+field[j+5]
			j=j+6	
		}
	}

		var data string
	for j:=0; j<int((len(Sbinary)+int(s.FillBits))/6);j++ {
		i, _ := strconv.ParseInt(encdata[j], 2, 8)
		if i<40 {
			i=i+48
		} else {
		i=i+8+48
	}
	data = data + string(rune(i))
	}

	Raw = Raw +","+data+","

	if s.FillBitsValidity == true {
		Raw = Raw +strconv.FormatInt(int64(s.FillBits), 10)
	}
	
	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
`
const NewNnmeaStruct = `
type %[1]s struct {
	%[2]s
	Core%[1]s
}
`
