//History Position report(0x01), Iridium/3G
// Code generated by omnicom; DO NOT EDIT
package omnicom

import (
	"errors"
	"strconv"
)

type HPR struct {
	Header                         byte
	Msg_ID                         uint32
	Source_Flag                    uint32
	Count_Total_Data_Reports       uint32
	Count_Data_Reports_in_this_Msg uint32
	Data_Report                    []Data_Report
	Extention_Bit_Beacon_ID        uint32
	Beacon_ID                      uint32
	Padding                        uint32
	CRC                            uint32
}

func (HPR *HPR) Parse(input string) error {
	var err error
	if len(input) > 2136 {
		err = errors.New("Input message is longer than limit")
		return err
	}
	var count int = 0
	if count+8 > len(input) {
		err = errors.New("Input message length of HPR is shorter than required")
		return err
	}
	count = count + 8
	var num uint64
	if count+12 > len(input) {
		err = errors.New("Input message length of HPR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+12], 2, 32)
	HPR.Msg_ID = uint32(num*1 - 0)
	count = count + 12
	if err != nil {
		return err
	}
	if count+4 > len(input) {
		err = errors.New("Input message length of HPR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+4], 2, 32)
	HPR.Source_Flag = uint32(num*1 - 0)
	count = count + 4
	if err != nil {
		return err
	}
	if count+16 > len(input) {
		err = errors.New("Input message length of HPR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+16], 2, 32)
	HPR.Count_Total_Data_Reports = uint32(num*1 - 0)
	count = count + 16
	if err != nil {
		return err
	}
	if count+8 > len(input) {
		err = errors.New("Input message length of HPR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	HPR.Count_Data_Reports_in_this_Msg = uint32(num*1 - 0)
	count = count + 8
	if err != nil {
		return err
	}
	HPR.Data_Report = make([]Data_Report, int(HPR.Count_Data_Reports_in_this_Msg))
	for i := 0; i < int(HPR.Count_Data_Reports_in_this_Msg); i++ {
		if count+158 > len(input) {
			err = errors.New("Input message length of HPR is shorter than required")
			return err
		}
		HPR.Data_Report[i] = *new(Data_Report)
		err = HPR.Data_Report[i].parse(input[count : count+158])
		count = count + 158
		if err != nil {
			return err
		}
	}
	if count+1 > len(input) {
		err = errors.New("Input message length of HPR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	HPR.Extention_Bit_Beacon_ID = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	if HPR.Extention_Bit_Beacon_ID == 1 {
		if count+20 > len(input) {
			err = errors.New("Input message length of HPR is shorter than required")
			return err
		}
		num, err = strconv.ParseUint(input[count:count+20], 2, 32)
		HPR.Beacon_ID = uint32(num*1 - 0)
		count = count + 20
		if err != nil {
			return err
		}
	}
	if count+(8-count%8) > len(input) {
		err = errors.New("Input message length of HPR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+(8-count%8)], 2, 32)
	HPR.Padding = uint32(num*1 - 0)
	count = count + (8 - count%8)
	if err != nil {
		return err
	}
	if count+8 > len(input) {
		err = errors.New("Input message length of HPR is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	HPR.CRC = uint32(num*1 - 0)
	count = count + 8
	if err != nil {
		return err
	}
	return err
}
func (HPR *HPR) Encode() ([]byte, error) {
	var str string
	var s string
	var err error
	str += pad(strconv.FormatUint(uint64(HPR.Header), 2), 8)
	s = pad(strconv.FormatUint(uint64((HPR.Msg_ID+0)/1), 2), 12)
	if len(s) > 12 {
		err = errors.New("Value assigned for HPR.Msg_ID exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((HPR.Source_Flag+0)/1), 2), 4)
	if len(s) > 4 {
		err = errors.New("Value assigned for HPR.Source_Flag exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((HPR.Count_Total_Data_Reports+0)/1), 2), 16)
	if len(s) > 16 {
		err = errors.New("Value assigned for HPR.Count_Total_Data_Reports exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((HPR.Count_Data_Reports_in_this_Msg+0)/1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for HPR.Count_Data_Reports_in_this_Msg exceeds limit")
		return []byte{}, err
	}
	str += s

	for i := 0; i < int(HPR.Count_Data_Reports_in_this_Msg); i++ {
		s, err = HPR.Data_Report[i].encode()
		if err != nil {
			return []byte{}, err
		}
		str += s
	}

	s = pad(strconv.FormatUint(uint64((HPR.Extention_Bit_Beacon_ID+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for HPR.Extention_Bit_Beacon_ID exceeds limit")
		return []byte{}, err
	}
	str += s

	if HPR.Extention_Bit_Beacon_ID == 1 {
		s = pad(strconv.FormatUint(uint64((HPR.Beacon_ID+0)/1), 2), 20)
		if len(s) > 20 {
			err = errors.New("Value assigned for HPR.Beacon_ID exceeds limit")
			return []byte{}, err
		}
		str += s

	}
	s = pad(strconv.FormatUint(uint64((HPR.Padding+0)/1), 2), 8-len(str)%8)
	if len(s) > (8 - len(str)%8) {
		err = errors.New("Value assigned for HPR.Padding exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((HPR.CRC+0)/1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for HPR.CRC exceeds limit")
		return []byte{}, err
	}
	str += s

	str = attachCRC(str)
	byteList, err := decToByte(str)
	return byteList, err
}
func (HPR *HPR) getHeader() byte {
	return HPR.Header
}
func (HPR *HPR) getCRC() uint32 {
	return HPR.CRC
}
func (HPR *HPR) setCRC(crc uint32) {
	HPR.CRC = crc
}
