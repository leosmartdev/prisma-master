// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixTTM prefix
	PrefixTTM = "TTM"
)

// TTM represents fix data.
type CoreTTM struct {
	Number uint32

	NumberValidity bool

	Distance float64

	DistanceValidity bool

	Bearing float64

	BearingValidity bool

	BearingRelative string

	BearingRelativeValidity bool

	Speed float64

	SpeedValidity bool

	Course float64

	CourseValidity bool

	CourseRelative string

	CourseRelativeValidity bool

	CpaDistance float64

	CpaDistanceValidity bool

	CpaTime float64

	CpaTimeValidity bool

	SpeedDistanceUnits string

	SpeedDistanceUnitsValidity bool

	Name string

	NameValidity bool

	Status string

	StatusValidity bool

	Reference string

	ReferenceValidity bool

	UtcTime float64

	UtcTimeValidity bool

	AcquisitionType string

	AcquisitionTypeValidity bool
}

type TTM struct {
	BaseSentence
	CoreTTM
}

func NewTTM(sentence BaseSentence) *TTM {
	s := new(TTM)
	s.BaseSentence = sentence

	s.NumberValidity = false

	s.DistanceValidity = false

	s.BearingValidity = false

	s.BearingRelativeValidity = false

	s.SpeedValidity = false

	s.CourseValidity = false

	s.CourseRelativeValidity = false

	s.CpaDistanceValidity = false

	s.CpaTimeValidity = false

	s.SpeedDistanceUnitsValidity = false

	s.NameValidity = false

	s.StatusValidity = false

	s.ReferenceValidity = false

	s.UtcTimeValidity = false

	s.AcquisitionTypeValidity = false

	return s
}

func (s *TTM) parse() error {
	var err error

	if s.Format != PrefixTTM {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixTTM)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseUint(s.Fields[0], 10, 32)
			if err != nil {
				return fmt.Errorf("TTM decode variation error: %s", s.Fields[0])
			} else {
				s.CoreTTM.Number = uint32(i)
				s.CoreTTM.NumberValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseFloat(s.Fields[1], 64)
			if err != nil {
				return fmt.Errorf("TTM decode variation error: %s", s.Fields[1])
			} else {
				s.CoreTTM.Distance = float64(i)
				s.CoreTTM.DistanceValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseFloat(s.Fields[2], 64)
			if err != nil {
				return fmt.Errorf("TTM decode variation error: %s", s.Fields[2])
			} else {
				s.CoreTTM.Bearing = float64(i)
				s.CoreTTM.BearingValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			s.BearingRelative = s.Fields[3]
			s.BearingRelativeValidity = true
		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseFloat(s.Fields[4], 64)
			if err != nil {
				return fmt.Errorf("TTM decode variation error: %s", s.Fields[4])
			} else {
				s.CoreTTM.Speed = float64(i)
				s.CoreTTM.SpeedValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			i, err := strconv.ParseFloat(s.Fields[5], 64)
			if err != nil {
				return fmt.Errorf("TTM decode variation error: %s", s.Fields[5])
			} else {
				s.CoreTTM.Course = float64(i)
				s.CoreTTM.CourseValidity = true
			}

		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			s.CourseRelative = s.Fields[6]
			s.CourseRelativeValidity = true
		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			i, err := strconv.ParseFloat(s.Fields[7], 64)
			if err != nil {
				return fmt.Errorf("TTM decode variation error: %s", s.Fields[7])
			} else {
				s.CoreTTM.CpaDistance = float64(i)
				s.CoreTTM.CpaDistanceValidity = true
			}

		}
	}

	if len(s.Fields) == 8 {
		return nil
	} else {
		if s.Fields[8] != "" {
			i, err := strconv.ParseFloat(s.Fields[8], 64)
			if err != nil {
				return fmt.Errorf("TTM decode variation error: %s", s.Fields[8])
			} else {
				s.CoreTTM.CpaTime = float64(i)
				s.CoreTTM.CpaTimeValidity = true
			}

		}
	}

	if len(s.Fields) == 9 {
		return nil
	} else {
		if s.Fields[9] != "" {
			s.SpeedDistanceUnits = s.Fields[9]
			s.SpeedDistanceUnitsValidity = true
		}
	}

	if len(s.Fields) == 10 {
		return nil
	} else {
		if s.Fields[10] != "" {
			s.Name = s.Fields[10]
			s.NameValidity = true
		}
	}

	if len(s.Fields) == 11 {
		return nil
	} else {
		if s.Fields[11] != "" {
			s.Status = s.Fields[11]
			s.StatusValidity = true
		}
	}

	if len(s.Fields) == 12 {
		return nil
	} else {
		if s.Fields[12] != "" {
			s.Reference = s.Fields[12]
			s.ReferenceValidity = true
		}
	}

	if len(s.Fields) == 13 {
		return nil
	} else {
		if s.Fields[13] != "" {
			i, err := strconv.ParseFloat(s.Fields[13], 64)
			if err != nil {
				return fmt.Errorf("TTM decode variation error: %s", s.Fields[13])
			} else {
				s.CoreTTM.UtcTime = float64(i)
				s.CoreTTM.UtcTimeValidity = true
			}

		}
	}

	if len(s.Fields) == 14 {
		return nil
	} else {
		if s.Fields[14] != "" {
			s.AcquisitionType = s.Fields[14]
			s.AcquisitionTypeValidity = true
		}
	}

	return nil
}

func (s *TTM) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixTTM {
		err := fmt.Errorf("Sentence format %s is not a TTM sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.NumberValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTTM.Number), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreTTM.Number), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.DistanceValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreTTM.Distance, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreTTM.Distance, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.BearingValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreTTM.Bearing, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreTTM.Bearing, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.BearingRelativeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTTM.BearingRelative

		} else {
			Raw = Raw + "," + s.CoreTTM.BearingRelative
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SpeedValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreTTM.Speed, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreTTM.Speed, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.CourseValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreTTM.Course, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreTTM.Course, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.CourseRelativeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTTM.CourseRelative

		} else {
			Raw = Raw + "," + s.CoreTTM.CourseRelative
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.CpaDistanceValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreTTM.CpaDistance, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreTTM.CpaDistance, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.CpaTimeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreTTM.CpaTime, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreTTM.CpaTime, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SpeedDistanceUnitsValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTTM.SpeedDistanceUnits

		} else {
			Raw = Raw + "," + s.CoreTTM.SpeedDistanceUnits
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.NameValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTTM.Name

		} else {
			Raw = Raw + "," + s.CoreTTM.Name
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StatusValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTTM.Status

		} else {
			Raw = Raw + "," + s.CoreTTM.Status
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ReferenceValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTTM.Reference

		} else {
			Raw = Raw + "," + s.CoreTTM.Reference
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.UtcTimeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreTTM.UtcTime, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreTTM.UtcTime, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.AcquisitionTypeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreTTM.AcquisitionType

		} else {
			Raw = Raw + "," + s.CoreTTM.AcquisitionType
		}
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
