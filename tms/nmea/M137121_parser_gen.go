// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strconv"
import "strings"

// M137121 represents fix data.
type CoreM137121 struct {
	MessageID uint8

	RepeatIndicator uint32

	Mmsi uint32

	A2nType uint32

	Name string

	PositionAccuracy bool

	Longitude float64

	Latitude float64

	DimBow uint32

	Dimstern uint32

	DimPort uint32

	DimStarboard uint32

	PositionDevice uint32

	TimeStamp uint32

	OffPosIndicator bool

	A2nStatus uint32

	RaimFlag bool

	VirtualFlag bool

	AssignedModeFlag bool

	Spare1 uint32 //Supposed to be Unknown

	NameExtension string

	Spare2 uint32 //Supposed to be Unknown
}
type M137121 struct {
	VDMO
	CoreM137121
}

func NewM137121(sentence VDMO) *M137121 {
	s := new(M137121)
	s.VDMO = sentence
	return s
}

func (s *M137121) parse() error {
	var err error

	if MessageType(s.EncapData) != 21 {
		err = fmt.Errorf("message %d is not a M137121", MessageType(s.EncapData))
		return err
	}

	data := []byte(s.EncapData)

	//if len(data)*6 > 362 {
	//	err = fmt.Errorf("Message lenght is larger than it should be [%d!=362]", len(data)*6)
	//	return err
	//}

	s.MessageID = MessageType(s.EncapData)

	s.CoreM137121.RepeatIndicator = BitsToInt(6, 7, data)

	s.CoreM137121.Mmsi = BitsToInt(8, 37, data)

	s.CoreM137121.A2nType = BitsToInt(38, 42, data)

	s.CoreM137121.Name = BitsToString(43, 162, data)

	s.CoreM137121.PositionAccuracy = CbnBool(163, data)

	s.CoreM137121.Longitude = (float64(int32(BitsToInt(164, 191, data)) << 4)) / 16

	s.CoreM137121.Latitude = (float64(int32(BitsToInt(192, 218, data)) << 5)) / 32

	s.CoreM137121.DimBow = BitsToInt(219, 227, data)

	s.CoreM137121.Dimstern = BitsToInt(228, 236, data)

	s.CoreM137121.DimPort = BitsToInt(237, 242, data)

	s.CoreM137121.DimStarboard = BitsToInt(243, 248, data)

	s.CoreM137121.PositionDevice = BitsToInt(249, 252, data)

	s.CoreM137121.TimeStamp = BitsToInt(253, 258, data)

	s.CoreM137121.OffPosIndicator = CbnBool(259, data)

	s.CoreM137121.A2nStatus = BitsToInt(260, 267, data)

	s.CoreM137121.RaimFlag = CbnBool(268, data)

	s.CoreM137121.VirtualFlag = CbnBool(269, data)

	s.CoreM137121.AssignedModeFlag = CbnBool(270, data)

	s.CoreM137121.Spare1 = BitsToInt(271, 271, data)

	s.CoreM137121.NameExtension = BitsToString(272, 355, data)

	s.CoreM137121.Spare2 = BitsToInt(356, 6*(len(data)-1), data)

	return nil
}

func (s *M137121) Encode() (string, error) {
	var Raw string
	var Sbinary string

	if s.MessageID != 21 {
		err := fmt.Errorf("message %d is not a M137121", s.MessageID)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format + ","

	if s.SentenceCountValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SentenceCount), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.SentenceIndexValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SentenceIndex), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.SeqMsgIDValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SeqMsgID), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.ChannelValidity == true {
		Raw = Raw + s.Channel
	}

	str := strconv.FormatInt(int64(s.CoreM137121.MessageID), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.RepeatIndicator), 2)
	for len(str) < 2 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.Mmsi), 2)
	for len(str) < 30 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.A2nType), 2)
	for len(str) < 5 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	if s.CoreM137121.Name != "" {
		str = ""

		for len([]byte(s.CoreM137121.Name)) < 120/6 {
			s.CoreM137121.Name = s.CoreM137121.Name + "@"

		}

		for _, n := range []byte(s.CoreM137121.Name) {
			if n >= 32 {
				n = n - 64
			}
			name := strconv.FormatInt(int64(n), 2)
			for len(name) < 6 {
				name = "0" + name
			}

			if len(name) > 6 {
				if len(name) == 8 {
					n = n - 128
					name = strconv.FormatInt(int64(n), 2)
				}
				if len(name) == 7 {
					n = n - 64
					name = strconv.FormatInt(int64(n), 2)
				}
			}

			str = str + name

		}

		Sbinary = Sbinary + str

	}

	if s.PositionAccuracy == true {
		str = "1"
	} else {
		str = "0"
	}

	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.Longitude), 2)
	for len(str) < 28 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.Latitude), 2)
	for len(str) < 27 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.DimBow), 2)
	for len(str) < 9 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.Dimstern), 2)
	for len(str) < 9 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.DimPort), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.DimStarboard), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.PositionDevice), 2)
	for len(str) < 4 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.TimeStamp), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	if s.OffPosIndicator == true {
		str = "1"
	} else {
		str = "0"
	}

	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.A2nStatus), 2)
	for len(str) < 8 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	if s.RaimFlag == true {
		str = "1"
	} else {
		str = "0"
	}

	Sbinary = Sbinary + str

	if s.VirtualFlag == true {
		str = "1"
	} else {
		str = "0"
	}

	Sbinary = Sbinary + str

	if s.AssignedModeFlag == true {
		str = "1"
	} else {
		str = "0"
	}

	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137121.Spare1), 2)
	for len(str) < 1 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	if s.CoreM137121.NameExtension != "" {
		str = ""

		for len([]byte(s.CoreM137121.NameExtension)) < 84/6 {
			s.CoreM137121.NameExtension = s.CoreM137121.NameExtension + "@"

		}

		for _, n := range []byte(s.CoreM137121.NameExtension) {
			if n >= 32 {
				n = n - 64
			}
			name := strconv.FormatInt(int64(n), 2)
			for len(name) < 6 {
				name = "0" + name
			}

			if len(name) > 6 {
				if len(name) == 8 {
					n = n - 128
					name = strconv.FormatInt(int64(n), 2)
				}
				if len(name) == 7 {
					n = n - 64
					name = strconv.FormatInt(int64(n), 2)
				}
			}

			str = str + name

		}

		Sbinary = Sbinary + str

	}

	str = strconv.FormatInt(int64(s.CoreM137121.Spare2), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	field := strings.SplitN(Sbinary, "", len(Sbinary))

	var encdata = make([]string, int((len(Sbinary)+int(s.FillBits))/6))

	j := 0
	for i := 0; i < int((len(Sbinary)+int(s.FillBits))/6); i++ {

		if i == (int((len(Sbinary)+int(s.FillBits))/6) - 1) {
			for j < len(Sbinary) {
				encdata[i] = encdata[i] + field[j]
				j = j + 1
			}
			for h := 0; h < int(s.FillBits); h++ {
				encdata[i] = encdata[i] + "0" // fill bits
			}
		} else {
			encdata[i] = field[j] + field[j+1] + field[j+2] + field[j+3] + field[j+4] + field[j+5]
			j = j + 6
		}
	}

	var data string
	for j := 0; j < int((len(Sbinary)+int(s.FillBits))/6); j++ {
		i, _ := strconv.ParseInt(encdata[j], 2, 8)
		if i < 40 {
			i = i + 48
		} else {
			i = i + 8 + 48
		}
		data = data + string(rune(i))
	}

	Raw = Raw + "," + data + ","

	if s.FillBitsValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.FillBits), 10)
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
