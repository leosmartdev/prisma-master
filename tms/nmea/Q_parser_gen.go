// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"

const (
	// PrefixQ prefix
	PrefixQ = "Q"
)

// Q represents fix data.
type CoreQ struct {
	DestinationTalker string

	DestinationTalkerValidity bool

	ReqFormat string

	ReqFormatValidity bool
}

type Q struct {
	BaseSentence
	CoreQ
}

func NewQ(sentence BaseSentence) *Q {
	s := new(Q)
	s.BaseSentence = sentence

	s.DestinationTalkerValidity = false

	s.ReqFormatValidity = false

	return s
}

func (s *Q) parse() error {
	var err error

	if s.Format != PrefixQ {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixQ)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			s.DestinationTalker = s.Fields[0]
			s.DestinationTalkerValidity = true
		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			s.ReqFormat = s.Fields[1]
			s.ReqFormatValidity = true
		}
	}

	return nil
}

func (s *Q) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixQ {
		err := fmt.Errorf("Sentence format %s is not a Q sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.DestinationTalkerValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreQ.DestinationTalker

		} else {
			Raw = Raw + "," + s.CoreQ.DestinationTalker
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ReqFormatValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreQ.ReqFormat

		} else {
			Raw = Raw + "," + s.CoreQ.ReqFormat
		}
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
