// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strconv"
import "strings"

// M13715 represents fix data.
type CoreM13715 struct {
	MessageID uint8

	RepeatIndicator uint32

	Mmsi uint32

	AisVersion uint32

	ImoNumber uint32

	CallSign string

	Name string

	ShipAndCargoType uint32

	DimBow uint32

	DimStern uint32

	DimPort uint32

	DimStarboard uint32

	PositionDevice uint32

	EtaMonth uint32

	EtaDay uint32

	EtaHour uint32

	EtaMinute uint32

	Draught uint32

	Destination string

	DataTerminalAvail bool

	Spare uint32 //Supposed to be Unknown
}
type M13715 struct {
	VDMO
	CoreM13715
}

func NewM13715(sentence VDMO) *M13715 {
	s := new(M13715)
	s.VDMO = sentence
	return s
}

func (s *M13715) parse() error {
	var err error

	if MessageType(s.EncapData) != 5 {
		err = fmt.Errorf("message %d is not a M13715", MessageType(s.EncapData))
		return err
	}

	data := []byte(s.EncapData)

	//if len(data)*6 > 424 {
	//	err = fmt.Errorf("Message lenght is larger than it should be [%d!=424]", len(data)*6)
	//	return err
	//}

	s.MessageID = MessageType(s.EncapData)

	s.CoreM13715.RepeatIndicator = BitsToInt(6, 7, data)

	s.CoreM13715.Mmsi = BitsToInt(8, 37, data)

	s.CoreM13715.AisVersion = BitsToInt(38, 39, data)

	s.CoreM13715.ImoNumber = BitsToInt(40, 69, data)

	s.CoreM13715.CallSign = BitsToString(70, 111, data)

	s.CoreM13715.Name = BitsToString(112, 231, data)

	s.CoreM13715.ShipAndCargoType = BitsToInt(232, 239, data)

	s.CoreM13715.DimBow = BitsToInt(240, 248, data)

	s.CoreM13715.DimStern = BitsToInt(249, 257, data)

	s.CoreM13715.DimPort = BitsToInt(258, 263, data)

	s.CoreM13715.DimStarboard = BitsToInt(264, 269, data)

	s.CoreM13715.PositionDevice = BitsToInt(270, 273, data)

	s.CoreM13715.EtaMonth = BitsToInt(274, 277, data)

	s.CoreM13715.EtaDay = BitsToInt(278, 282, data)

	s.CoreM13715.EtaHour = BitsToInt(283, 287, data)

	s.CoreM13715.EtaMinute = BitsToInt(288, 293, data)

	s.CoreM13715.Draught = BitsToInt(294, 301, data)

	s.CoreM13715.Destination = BitsToString(302, 421, data)

	s.CoreM13715.DataTerminalAvail = CbnBool(422, data)

	s.CoreM13715.Spare = BitsToInt(423, 6*(len(data)-1), data)

	return nil
}

func (s *M13715) Encode() (string, error) {
	var Raw string
	var Sbinary string

	if s.MessageID != 5 {
		err := fmt.Errorf("message %d is not a M13715", s.MessageID)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format + ","

	if s.SentenceCountValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SentenceCount), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.SentenceIndexValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SentenceIndex), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.SeqMsgIDValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SeqMsgID), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.ChannelValidity == true {
		Raw = Raw + s.Channel
	}

	str := strconv.FormatInt(int64(s.CoreM13715.MessageID), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.RepeatIndicator), 2)
	for len(str) < 2 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.Mmsi), 2)
	for len(str) < 30 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.AisVersion), 2)
	for len(str) < 2 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.ImoNumber), 2)
	for len(str) < 30 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	if s.CoreM13715.CallSign != "" {
		str = ""

		for len([]byte(s.CoreM13715.CallSign)) < 42/6 {
			s.CoreM13715.CallSign = s.CoreM13715.CallSign + "@"

		}

		for _, n := range []byte(s.CoreM13715.CallSign) {
			if n >= 32 {
				n = n - 64
			}
			name := strconv.FormatInt(int64(n), 2)
			for len(name) < 6 {
				name = "0" + name
			}

			if len(name) > 6 {
				if len(name) == 8 {
					n = n - 128
					name = strconv.FormatInt(int64(n), 2)
				}
				if len(name) == 7 {
					n = n - 64
					name = strconv.FormatInt(int64(n), 2)
				}
			}

			str = str + name

		}

		Sbinary = Sbinary + str

	}

	if s.CoreM13715.Name != "" {
		str = ""

		for len([]byte(s.CoreM13715.Name)) < 120/6 {
			s.CoreM13715.Name = s.CoreM13715.Name + "@"

		}

		for _, n := range []byte(s.CoreM13715.Name) {
			if n >= 32 {
				n = n - 64
			}
			name := strconv.FormatInt(int64(n), 2)
			for len(name) < 6 {
				name = "0" + name
			}

			if len(name) > 6 {
				if len(name) == 8 {
					n = n - 128
					name = strconv.FormatInt(int64(n), 2)
				}
				if len(name) == 7 {
					n = n - 64
					name = strconv.FormatInt(int64(n), 2)
				}
			}

			str = str + name

		}

		Sbinary = Sbinary + str

	}

	str = strconv.FormatInt(int64(s.CoreM13715.ShipAndCargoType), 2)
	for len(str) < 8 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.DimBow), 2)
	for len(str) < 9 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.DimStern), 2)
	for len(str) < 9 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.DimPort), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.DimStarboard), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.PositionDevice), 2)
	for len(str) < 4 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.EtaMonth), 2)
	for len(str) < 4 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.EtaDay), 2)
	for len(str) < 5 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.EtaHour), 2)
	for len(str) < 5 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.EtaMinute), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.Draught), 2)
	for len(str) < 8 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	if s.CoreM13715.Destination != "" {
		str = ""

		for len([]byte(s.CoreM13715.Destination)) < 120/6 {
			s.CoreM13715.Destination = s.CoreM13715.Destination + "@"

		}

		for _, n := range []byte(s.CoreM13715.Destination) {
			if n >= 32 {
				n = n - 64
			}
			name := strconv.FormatInt(int64(n), 2)
			for len(name) < 6 {
				name = "0" + name
			}

			if len(name) > 6 {
				if len(name) == 8 {
					n = n - 128
					name = strconv.FormatInt(int64(n), 2)
				}
				if len(name) == 7 {
					n = n - 64
					name = strconv.FormatInt(int64(n), 2)
				}
			}

			str = str + name

		}

		Sbinary = Sbinary + str

	}

	if s.DataTerminalAvail == true {
		str = "1"
	} else {
		str = "0"
	}

	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM13715.Spare), 2)
	for len(str) < 1 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	field := strings.SplitN(Sbinary, "", len(Sbinary))

	var encdata = make([]string, int((len(Sbinary)+int(s.FillBits))/6))

	j := 0
	for i := 0; i < int((len(Sbinary)+int(s.FillBits))/6); i++ {

		if i == (int((len(Sbinary)+int(s.FillBits))/6) - 1) {
			for j < len(Sbinary) {
				encdata[i] = encdata[i] + field[j]
				j = j + 1
			}
			for h := 0; h < int(s.FillBits); h++ {
				encdata[i] = encdata[i] + "0" // fill bits
			}
		} else {
			encdata[i] = field[j] + field[j+1] + field[j+2] + field[j+3] + field[j+4] + field[j+5]
			j = j + 6
		}
	}

	var data string
	for j := 0; j < int((len(Sbinary)+int(s.FillBits))/6); j++ {
		i, _ := strconv.ParseInt(encdata[j], 2, 8)
		if i < 40 {
			i = i + 48
		} else {
			i = i + 8 + 48
		}
		data = data + string(rune(i))
	}

	Raw = Raw + "," + data + ","

	if s.FillBitsValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.FillBits), 10)
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
