// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strconv"
import "strings"

// M137119 represents fix data.
type CoreM137119 struct {
	MessageID uint8

	RepeatIndicator uint32

	Mmsi uint32

	Spare1 uint32 //Supposed to be Unknown

	SpeedOverGround uint32

	PositionAccuracy bool

	Longitude float64

	Latitude float64

	CourseOverGround uint32

	TrueHeading uint32

	TimeStamp uint32

	Spare2 uint32 //Supposed to be Unknown

	Name string

	ShipAndCargoType uint32

	DimBow uint32

	DimStern uint32

	DimPort uint32

	DimStarboard uint32

	PositionDevice uint32

	RaimFlag bool

	DataTerminalAvail bool

	AssignedModeFlag bool

	Spare3 uint32 //Supposed to be Unknown
}
type M137119 struct {
	VDMO
	CoreM137119
}

func NewM137119(sentence VDMO) *M137119 {
	s := new(M137119)
	s.VDMO = sentence
	return s
}

func (s *M137119) parse() error {
	var err error

	if MessageType(s.EncapData) != 19 {
		err = fmt.Errorf("message %d is not a M137119", MessageType(s.EncapData))
		return err
	}

	data := []byte(s.EncapData)

	//if len(data)*6 > 312 {
	//	err = fmt.Errorf("Message lenght is larger than it should be [%d!=312]", len(data)*6)
	//	return err
	//}

	s.MessageID = MessageType(s.EncapData)

	s.CoreM137119.RepeatIndicator = BitsToInt(6, 7, data)

	s.CoreM137119.Mmsi = BitsToInt(8, 37, data)

	s.CoreM137119.Spare1 = BitsToInt(38, 45, data)

	s.CoreM137119.SpeedOverGround = BitsToInt(46, 55, data)

	s.CoreM137119.PositionAccuracy = CbnBool(56, data)

	s.CoreM137119.Longitude = (float64(int32(BitsToInt(57, 84, data)) << 4)) / 16

	s.CoreM137119.Latitude = (float64(int32(BitsToInt(85, 111, data)) << 5)) / 32

	s.CoreM137119.CourseOverGround = BitsToInt(112, 123, data)

	s.CoreM137119.TrueHeading = BitsToInt(124, 132, data)

	s.CoreM137119.TimeStamp = BitsToInt(133, 138, data)

	s.CoreM137119.Spare2 = BitsToInt(139, 142, data)

	s.CoreM137119.Name = BitsToString(143, 262, data)

	s.CoreM137119.ShipAndCargoType = BitsToInt(263, 270, data)

	s.CoreM137119.DimBow = BitsToInt(271, 279, data)

	s.CoreM137119.DimStern = BitsToInt(280, 288, data)

	s.CoreM137119.DimPort = BitsToInt(289, 294, data)

	s.CoreM137119.DimStarboard = BitsToInt(295, 300, data)

	s.CoreM137119.PositionDevice = BitsToInt(301, 304, data)

	s.CoreM137119.RaimFlag = CbnBool(305, data)

	s.CoreM137119.DataTerminalAvail = CbnBool(306, data)

	s.CoreM137119.AssignedModeFlag = CbnBool(307, data)

	s.CoreM137119.Spare3 = BitsToInt(308, 6*(len(data)-1), data)

	return nil
}

func (s *M137119) Encode() (string, error) {
	var Raw string
	var Sbinary string

	if s.MessageID != 19 {
		err := fmt.Errorf("message %d is not a M137119", s.MessageID)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format + ","

	if s.SentenceCountValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SentenceCount), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.SentenceIndexValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SentenceIndex), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.SeqMsgIDValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SeqMsgID), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.ChannelValidity == true {
		Raw = Raw + s.Channel
	}

	str := strconv.FormatInt(int64(s.CoreM137119.MessageID), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.RepeatIndicator), 2)
	for len(str) < 2 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.Mmsi), 2)
	for len(str) < 30 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.Spare1), 2)
	for len(str) < 8 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.SpeedOverGround), 2)
	for len(str) < 10 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	if s.PositionAccuracy == true {
		str = "1"
	} else {
		str = "0"
	}

	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.Longitude), 2)
	for len(str) < 28 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.Latitude), 2)
	for len(str) < 27 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.CourseOverGround), 2)
	for len(str) < 12 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.TrueHeading), 2)
	for len(str) < 9 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.TimeStamp), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.Spare2), 2)
	for len(str) < 4 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	if s.CoreM137119.Name != "" {
		str = ""

		for len([]byte(s.CoreM137119.Name)) < 120/6 {
			s.CoreM137119.Name = s.CoreM137119.Name + "@"

		}

		for _, n := range []byte(s.CoreM137119.Name) {
			if n >= 32 {
				n = n - 64
			}
			name := strconv.FormatInt(int64(n), 2)
			for len(name) < 6 {
				name = "0" + name
			}

			if len(name) > 6 {
				if len(name) == 8 {
					n = n - 128
					name = strconv.FormatInt(int64(n), 2)
				}
				if len(name) == 7 {
					n = n - 64
					name = strconv.FormatInt(int64(n), 2)
				}
			}

			str = str + name

		}

		Sbinary = Sbinary + str

	}

	str = strconv.FormatInt(int64(s.CoreM137119.ShipAndCargoType), 2)
	for len(str) < 8 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.DimBow), 2)
	for len(str) < 9 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.DimStern), 2)
	for len(str) < 9 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.DimPort), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.DimStarboard), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.PositionDevice), 2)
	for len(str) < 4 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	if s.RaimFlag == true {
		str = "1"
	} else {
		str = "0"
	}

	Sbinary = Sbinary + str

	if s.DataTerminalAvail == true {
		str = "1"
	} else {
		str = "0"
	}

	Sbinary = Sbinary + str

	if s.AssignedModeFlag == true {
		str = "1"
	} else {
		str = "0"
	}

	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137119.Spare3), 2)
	for len(str) < 4 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	field := strings.SplitN(Sbinary, "", len(Sbinary))

	var encdata = make([]string, int((len(Sbinary)+int(s.FillBits))/6))

	j := 0
	for i := 0; i < int((len(Sbinary)+int(s.FillBits))/6); i++ {

		if i == (int((len(Sbinary)+int(s.FillBits))/6) - 1) {
			for j < len(Sbinary) {
				encdata[i] = encdata[i] + field[j]
				j = j + 1
			}
			for h := 0; h < int(s.FillBits); h++ {
				encdata[i] = encdata[i] + "0" // fill bits
			}
		} else {
			encdata[i] = field[j] + field[j+1] + field[j+2] + field[j+3] + field[j+4] + field[j+5]
			j = j + 6
		}
	}

	var data string
	for j := 0; j < int((len(Sbinary)+int(s.FillBits))/6); j++ {
		i, _ := strconv.ParseInt(encdata[j], 2, 8)
		if i < 40 {
			i = i + 48
		} else {
			i = i + 8 + 48
		}
		data = data + string(rune(i))
	}

	Raw = Raw + "," + data + ","

	if s.FillBitsValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.FillBits), 10)
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
