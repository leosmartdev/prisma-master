// +build ignore

// check_rules generates a file that checks different conditions with the same logic.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	//"prisma/tms/rule"
	"strings"
	//"prisma/tms/util/rule/op"
)

//go:generate go run check_rules.go --file $GOPATH/src/prisma/tms/rule/check_rules_gen.go

var tplFuncCheckRuleForTarget = `
// check a rule for a target. Return bool - is this check ok
func checkRuleForTarget{{IFRULE}}(cond Rule_If{{IFRULE}}, track tms.Track) bool {
	var target *tms.Target
	if len(track.Targets) > 0 {
		target = track.Targets[0]
	} else {
		return false
	}
	switch cond.Operation {
	case Rule_EQUAL:
		return checkTargetByOperation{{IFRULE}}(cond, *target, compEqualValue)
	case Rule_LESSER:
		return checkTargetByOperation{{IFRULE}}(cond, *target, compLesserValue)
	case Rule_LESSER_EQUAL:
		return checkTargetByOperation{{IFRULE}}(cond, *target, compLesserEqualValue)
	case Rule_GREATER:
		return checkTargetByOperation{{IFRULE}}(cond, *target, compGreaterValue)
	case Rule_GREATER_EQUAL:
		return checkTargetByOperation{{IFRULE}}(cond, *target, compGreaterEqualValue)
	case Rule_REGEX:
		return checkTargetByOperation{{IFRULE}}(cond, *target, compRegExValue)
	}
	return false
}
`

var tplFuncCheckRuleForTrack = `
// check a rule for a track. Return bool - is this check ok
func checkRuleForTrack{{IFRULE}}(cond Rule_If{{IFRULE}}, track tms.Track) bool {
	switch cond.Operation {
	case Rule_TOWARD:
		trackCond := cond.GetTrack()
		return trackCond != nil && trackCond.RegistryId == track.RegistryId
	}
	return false
}
`

var tplFuncCheckRuleForZone = `
// check a rule for a track. Return bool - is this check ok
func checkRuleForZone{{IFRULE}}(cond Rule_If{{IFRULE}}, track tms.Track,
		zones ZoneStore, insideZone map[string]map[string]bool) bool {
	var (
		target 		*tms.Target
		zoneByName 	*moc.Zone
		err 		error
	)
	if len(track.Targets) > 0 && cond.GetZone() != nil {
		target = track.Targets[0]
	} else {
		return false
	}
	if zoneByName, err = zones.GetByName(cond.GetZone().Name); err != nil {
		return false
	}

	if insideZone[cond.GetZone().Name] == nil {
		insideZone[cond.GetZone().Name] = make(map[string]bool)
	}
	isInside := zoneByName.Poly.ToGeo().Nearby(target.Point().Coordinates, 0)
	if isInside {
		insideZone[cond.GetZone().Name][track.LookupID()] = true
	}
	_, wasInside := insideZone[cond.GetZone().Name][track.LookupID()]

	switch cond.Operation {
	case Rule_IN:
		if isInside {
			insideZone[cond.GetZone().Name][track.LookupID()] = true
			return true
		}
	case Rule_OUT:
		if !isInside && wasInside {
		 	delete(insideZone[cond.GetZone().Name], track.LookupID())
			return true
		}
	}
	return false
}
`

var tplFuncCheckSOMEByOperation = `
// Check each fields which is pointed in condAll.CheckFields
func check{{GOAL}}ByOperation{{IFRULE}}(cond Rule_If{{IFRULE}}, original tms.{{TYPE_GOAL}}, cmp fncCmp) bool {
	// Golang's authors advice don't use reflect, so we will use reflect
	goal := cond.{{METHOD_GET_GOAL}}
	if goal == nil {
		return false
	}
	for _, field := range cond.CheckFields {
		val, valOriginal, err := getValueBySpecificField(goal, original, field)
		if err != nil {
			return false
		}
		if retBool, err := cmp(val, valOriginal); !retBool || err != nil {
			if err != nil {
				log.Error("%v", err)
			}
			return false
		}
	}
	return true
}
`

var ifRule = []string{"Any", "All"}
var Goal = []string{"Target"}
var GoalMethod = []string{"GetTarget()"}
var GoalType = []string{"Target"}

func main() {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "// prisma/tms/generator/rule/check_rules.go\n")
	fmt.Fprintf(&bb, "// GENERATED BY THE FILE ABOVE; DO NOT EDIT\n\n")
	fmt.Fprintf(&bb, "package rule\n\n")
	fmt.Fprintf(&bb, `import (`)
	fmt.Fprintf(&bb, `"prisma/tms"`)
	fmt.Fprintf(&bb, "\n")
	fmt.Fprintf(&bb, `"prisma/tms/log"`)
	fmt.Fprintf(&bb, "\n")
	fmt.Fprintf(&bb, `"prisma/tms/moc"`)
	fmt.Fprintf(&bb, "\n)\n")
	fileOut := flag.String("file", "check_rules.go", "output file")
	flag.Parse()
	for _, valIfRule := range ifRule {
		fnc := strings.Replace(tplFuncCheckRuleForTarget, "{{IFRULE}}", valIfRule, -1)
		fmt.Fprintf(&bb, fnc)
	}
	for _, valIfRule := range ifRule {
		fnc := strings.Replace(tplFuncCheckRuleForZone, "{{IFRULE}}", valIfRule, -1)
		fmt.Fprintf(&bb, fnc)
	}
	for _, valIfRule := range ifRule {
		fnc := strings.Replace(tplFuncCheckRuleForTrack, "{{IFRULE}}", valIfRule, -1)
		fmt.Fprintf(&bb, fnc)
	}

	for i := range ifRule {
		for j := range Goal {
			fnc := strings.Replace(tplFuncCheckSOMEByOperation, "{{IFRULE}}", ifRule[i], -1)
			fnc = strings.Replace(fnc, "{{GOAL}}", Goal[j], -1)
			fnc = strings.Replace(fnc, "{{TYPE_GOAL}}", GoalType[j], -1)
			fnc = strings.Replace(fnc, "{{METHOD_GET_GOAL}}", GoalMethod[j], -1)
			fmt.Fprintf(&bb, fnc)
		}
	}

	if err := ioutil.WriteFile(*fileOut, bb.Bytes(), 0644); err != nil {
		os.Exit(1)
	}
}
