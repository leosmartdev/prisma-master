// Code generated by omnicom; DO NOT EDIT
package omnicom

import (
	"bytes"
	"errors"
	"strconv"
	"strings"
)

type Date_Position struct {
	Year      uint32
	Month     uint32
	Day       uint32
	Minute    uint32
	Longitude float32
	Latitude  float32
}

func (Date_Position *Date_Position) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+7], 2, 32)
	Date_Position.Year = uint32(num*1 - 0)
	count = count + 7
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+4], 2, 32)
	Date_Position.Month = uint32(num*1 - 0)
	count = count + 4
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+5], 2, 32)
	Date_Position.Day = uint32(num*1 - 0)
	count = count + 5
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+11], 2, 32)
	Date_Position.Minute = uint32(num*1 - 0)
	count = count + 11
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+22], 2, 32)
	Date_Position.Longitude = float32(num)*0.0001 - 180
	count = count + 22
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+21], 2, 32)
	Date_Position.Latitude = float32(num)*0.0001 - 90
	count = count + 21
	if err != nil {
		return err
	}
	return err
}
func (Date_Position *Date_Position) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Date_Position.Year+0)/1), 2), 7)
	if len(s) > 7 {
		err = errors.New("Value assigned for Date_Position.Year exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Date_Position.Month+0)/1), 2), 4)
	if len(s) > 4 {
		err = errors.New("Value assigned for Date_Position.Month exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Date_Position.Day+0)/1), 2), 5)
	if len(s) > 5 {
		err = errors.New("Value assigned for Date_Position.Day exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Date_Position.Minute+0)/1), 2), 11)
	if len(s) > 11 {
		err = errors.New("Value assigned for Date_Position.Minute exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Date_Position.Longitude+180)/0.0001), 2), 22)
	if len(s) > 22 {
		err = errors.New("Value assigned for Date_Position.Longitude exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Date_Position.Latitude+90)/0.0001), 2), 21)
	if len(s) > 21 {
		err = errors.New("Value assigned for Date_Position.Latitude exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Move struct {
	Speed   float32
	Heading uint32
}

func (Move *Move) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+9], 2, 32)
	Move.Speed = float32(num)*0.1 - 0
	count = count + 9
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+9], 2, 32)
	Move.Heading = uint32(num*1 - 0)
	count = count + 9
	if err != nil {
		return err
	}
	return err
}
func (Move *Move) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Move.Speed+0)/0.1), 2), 9)
	if len(s) > 9 {
		err = errors.New("Value assigned for Move.Speed exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Move.Heading+0)/1), 2), 9)
	if len(s) > 9 {
		err = errors.New("Value assigned for Move.Heading exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Data_Report struct {
	Number_Data_Report uint32
	Date_Position      Date_Position
	Move               Move
	Period             uint32
	Voltage            Voltage
	Geofence           Geofence
}
type Geofence struct {
	Status_Alert uint32
	GEO_ID       uint32
}
type Voltage struct {
	V_IN float32
}

func (Data_Report *Data_Report) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+16], 2, 32)
	Data_Report.Number_Data_Report = uint32(num*1 - 0)
	count = count + 16
	if err != nil {
		return err
	}
	Data_Report.Date_Position = *new(Date_Position)
	err = Data_Report.Date_Position.parse(input[count : count+70])
	count = count + 70
	if err != nil {
		return err
	}
	Data_Report.Move = *new(Move)
	err = Data_Report.Move.parse(input[count : count+18])
	count = count + 18
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+9], 2, 32)
	Data_Report.Period = uint32(num*5 - 0)
	count = count + 9
	if err != nil {
		return err
	}
	Data_Report.Voltage = *new(Voltage)
	err = Data_Report.Voltage.parse(input[count : count+10])
	count = count + 10
	if err != nil {
		return err
	}
	Data_Report.Geofence = *new(Geofence)
	err = Data_Report.Geofence.parse(input[count : count+35])
	count = count + 35
	if err != nil {
		return err
	}
	return err
}
func (Geofence *Geofence) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+3], 2, 32)
	Geofence.Status_Alert = uint32(num*1 - 0)
	count = count + 3
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+32], 2, 32)
	Geofence.GEO_ID = uint32(num*1 - 0)
	count = count + 32
	if err != nil {
		return err
	}
	return err
}
func (Voltage *Voltage) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+10], 2, 32)
	Voltage.V_IN = float32(num)*0.1 - 0
	count = count + 10
	if err != nil {
		return err
	}
	return err
}
func (Data_Report *Data_Report) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Data_Report.Number_Data_Report+0)/1), 2), 16)
	if len(s) > 16 {
		err = errors.New("Value assigned for Data_Report.Number_Data_Report exceeds limit")
		return str, err
	}
	str += s
	s, err = Data_Report.Date_Position.encode()
	if err != nil {
		return "", err
	}
	str += s
	s, err = Data_Report.Move.encode()
	if err != nil {
		return "", err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Data_Report.Period+0)/5), 2), 9)
	if len(s) > 9 {
		err = errors.New("Value assigned for Data_Report.Period exceeds limit")
		return str, err
	}
	str += s
	s, err = Data_Report.Voltage.encode()
	if err != nil {
		return "", err
	}
	str += s
	s, err = Data_Report.Geofence.encode()
	if err != nil {
		return "", err
	}
	str += s
	return str, err
}
func (Geofence *Geofence) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Geofence.Status_Alert+0)/1), 2), 3)
	if len(s) > 3 {
		err = errors.New("Value assigned for Geofence.Status_Alert exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Geofence.GEO_ID+0)/1), 2), 32)
	if len(s) > 32 {
		err = errors.New("Value assigned for Geofence.GEO_ID exceeds limit")
		return str, err
	}
	str += s
	return str, err
}
func (Voltage *Voltage) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Voltage.V_IN+0)/0.1), 2), 10)
	if len(s) > 10 {
		err = errors.New("Value assigned for Voltage.V_IN exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Date_Event struct {
	Year   uint32
	Month  uint32
	Day    uint32
	Minute uint32
}

func (Date_Event *Date_Event) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+7], 2, 32)
	Date_Event.Year = uint32(num*1 - 0)
	count = count + 7
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+4], 2, 32)
	Date_Event.Month = uint32(num*1 - 0)
	count = count + 4
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+5], 2, 32)
	Date_Event.Day = uint32(num*1 - 0)
	count = count + 5
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+11], 2, 32)
	Date_Event.Minute = uint32(num*1 - 0)
	count = count + 11
	if err != nil {
		return err
	}
	return err
}
func (Date_Event *Date_Event) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Date_Event.Year+0)/1), 2), 7)
	if len(s) > 7 {
		err = errors.New("Value assigned for Date_Event.Year exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Date_Event.Month+0)/1), 2), 4)
	if len(s) > 4 {
		err = errors.New("Value assigned for Date_Event.Month exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Date_Event.Day+0)/1), 2), 5)
	if len(s) > 5 {
		err = errors.New("Value assigned for Date_Event.Day exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Date_Event.Minute+0)/1), 2), 11)
	if len(s) > 11 {
		err = errors.New("Value assigned for Date_Event.Minute exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Power_Up struct {
	Alert_Status    uint32
	Power_Up_Status uint32
}

func (Power_Up *Power_Up) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Power_Up.Alert_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Power_Up.Power_Up_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Power_Up *Power_Up) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Power_Up.Alert_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Power_Up.Alert_Status exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Power_Up.Power_Up_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Power_Up.Power_Up_Status exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Power_Down struct {
	Alert_Status      uint32
	Power_Down_Status uint32
}

func (Power_Down *Power_Down) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Power_Down.Alert_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Power_Down.Power_Down_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Power_Down *Power_Down) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Power_Down.Alert_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Power_Down.Alert_Status exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Power_Down.Power_Down_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Power_Down.Power_Down_Status exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Battery_Alert struct {
	Alert_Status                 uint32
	Current_Battery_Alert_Status uint32
}

func (Battery_Alert *Battery_Alert) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Battery_Alert.Alert_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+2], 2, 32)
	Battery_Alert.Current_Battery_Alert_Status = uint32(num*1 - 0)
	count = count + 2
	if err != nil {
		return err
	}
	return err
}
func (Battery_Alert *Battery_Alert) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Battery_Alert.Alert_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Battery_Alert.Alert_Status exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Battery_Alert.Current_Battery_Alert_Status+0)/1), 2), 2)
	if len(s) > 2 {
		err = errors.New("Value assigned for Battery_Alert.Current_Battery_Alert_Status exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Intrusion_Alert struct {
	Alert_Status             uint32
	Current_Intrusion_Status uint32
}

func (Intrusion_Alert *Intrusion_Alert) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Intrusion_Alert.Alert_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Intrusion_Alert.Current_Intrusion_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Intrusion_Alert *Intrusion_Alert) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Intrusion_Alert.Alert_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Intrusion_Alert.Alert_Status exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Intrusion_Alert.Current_Intrusion_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Intrusion_Alert.Current_Intrusion_Status exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type No_Position_Fix struct {
	Alert_Status                   uint32
	Current_No_Position_Fix_Status uint32
	Number_Satellite_in_View       uint32
}

func (No_Position_Fix *No_Position_Fix) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	No_Position_Fix.Alert_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	No_Position_Fix.Current_No_Position_Fix_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+4], 2, 32)
	No_Position_Fix.Number_Satellite_in_View = uint32(num*1 - 0)
	count = count + 4
	if err != nil {
		return err
	}
	return err
}
func (No_Position_Fix *No_Position_Fix) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((No_Position_Fix.Alert_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for No_Position_Fix.Alert_Status exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((No_Position_Fix.Current_No_Position_Fix_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for No_Position_Fix.Current_No_Position_Fix_Status exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((No_Position_Fix.Number_Satellite_in_View+0)/1), 2), 4)
	if len(s) > 4 {
		err = errors.New("Value assigned for No_Position_Fix.Number_Satellite_in_View exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type JB_Dome_Alert struct {
	Alert_Status           uint32
	Current_JB_Dome_Status uint32
}

func (JB_Dome_Alert *JB_Dome_Alert) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	JB_Dome_Alert.Alert_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	JB_Dome_Alert.Current_JB_Dome_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (JB_Dome_Alert *JB_Dome_Alert) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((JB_Dome_Alert.Alert_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for JB_Dome_Alert.Alert_Status exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((JB_Dome_Alert.Current_JB_Dome_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for JB_Dome_Alert.Current_JB_Dome_Status exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Loss_Mobile_Com struct {
	Alert_Status                   uint32
	Current_Loss_Mobile_Com_Status uint32
}

func (Loss_Mobile_Com *Loss_Mobile_Com) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Loss_Mobile_Com.Alert_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Loss_Mobile_Com.Current_Loss_Mobile_Com_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Loss_Mobile_Com *Loss_Mobile_Com) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Loss_Mobile_Com.Alert_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Loss_Mobile_Com.Alert_Status exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Loss_Mobile_Com.Current_Loss_Mobile_Com_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Loss_Mobile_Com.Current_Loss_Mobile_Com_Status exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Daylight_Alert struct {
	Alert_Status           uint32
	Current_Daylight_Alert uint32
}

func (Daylight_Alert *Daylight_Alert) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Daylight_Alert.Alert_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Daylight_Alert.Current_Daylight_Alert = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Daylight_Alert *Daylight_Alert) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Daylight_Alert.Alert_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Daylight_Alert.Alert_Status exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Daylight_Alert.Current_Daylight_Alert+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Daylight_Alert.Current_Daylight_Alert exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Assistance_Alert struct {
	Alert_Status                    uint32
	Current_Assistance_Alert_Status uint32
}

func (Assistance_Alert *Assistance_Alert) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Assistance_Alert.Alert_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Assistance_Alert.Current_Assistance_Alert_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Assistance_Alert *Assistance_Alert) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Assistance_Alert.Alert_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Assistance_Alert.Alert_Status exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Assistance_Alert.Current_Assistance_Alert_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Assistance_Alert.Current_Assistance_Alert_Status exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Test_Mode struct {
	Alert_Status             uint32
	Current_Test_Mode_Status uint32
}

func (Test_Mode *Test_Mode) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Test_Mode.Alert_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Test_Mode.Current_Test_Mode_Status = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Test_Mode *Test_Mode) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Test_Mode.Alert_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Test_Mode.Alert_Status exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Test_Mode.Current_Test_Mode_Status+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Test_Mode.Current_Test_Mode_Status exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Position_Reporting_Interval struct {
	Value_in_mn uint32
	Modified    uint32
}

func (Position_Reporting_Interval *Position_Reporting_Interval) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+9], 2, 32)
	Position_Reporting_Interval.Value_in_mn = uint32(num*5 - 0)
	count = count + 9
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Position_Reporting_Interval.Modified = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Position_Reporting_Interval *Position_Reporting_Interval) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Position_Reporting_Interval.Value_in_mn+0)/5), 2), 9)
	if len(s) > 9 {
		err = errors.New("Value assigned for Position_Reporting_Interval.Value_in_mn exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Position_Reporting_Interval.Modified+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Position_Reporting_Interval.Modified exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Geofencing_Enable struct {
	On_Off   uint32
	Modified uint32
}

func (Geofencing_Enable *Geofencing_Enable) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Geofencing_Enable.On_Off = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Geofencing_Enable.Modified = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Geofencing_Enable *Geofencing_Enable) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Geofencing_Enable.On_Off+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Geofencing_Enable.On_Off exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Geofencing_Enable.Modified+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Geofencing_Enable.Modified exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Position_Collection_Interval struct {
	Value_in_mn uint32
	Modified    uint32
}

func (Position_Collection_Interval *Position_Collection_Interval) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+9], 2, 32)
	Position_Collection_Interval.Value_in_mn = uint32(num*1 - 0)
	count = count + 9
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Position_Collection_Interval.Modified = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Position_Collection_Interval *Position_Collection_Interval) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Position_Collection_Interval.Value_in_mn+0)/1), 2), 9)
	if len(s) > 9 {
		err = errors.New("Value assigned for Position_Collection_Interval.Value_in_mn exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Position_Collection_Interval.Modified+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Position_Collection_Interval.Modified exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Password struct {
	Value_in_mn []byte
	Modified    uint32
}

func (Password *Password) parse(input string) error {
	var err error
	var count int = 0
	Password.Value_in_mn, err = decodeToByte(input[count : count+120])
	count = count + 120
	if err != nil {
		return err
	}
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Password.Modified = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Password *Password) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s, err = encodeFromByte(Password.Value_in_mn, 120)
	if err != nil {
		return "", err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Password.Modified+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Password.Modified exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Routing struct {
	Value_in_mn uint32
	Modified    uint32
}

func (Routing *Routing) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+2], 2, 32)
	Routing.Value_in_mn = uint32(num*1 - 0)
	count = count + 2
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Routing.Modified = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Routing *Routing) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Routing.Value_in_mn+0)/1), 2), 2)
	if len(s) > 2 {
		err = errors.New("Value assigned for Routing.Value_in_mn exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Routing.Modified+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Routing.Modified exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Web_Service_API_URL_Sending struct {
	Value    []byte
	Modified uint32
}

func (Web_Service_API_URL_Sending *Web_Service_API_URL_Sending) parse(input string) error {
	var err error
	var count int = 0
	Web_Service_API_URL_Sending.Value, err = decodeToByte(input[count : count+600])
	count = count + 600
	if err != nil {
		return err
	}
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Web_Service_API_URL_Sending.Modified = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Web_Service_API_URL_Sending *Web_Service_API_URL_Sending) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s, err = encodeFromByte(Web_Service_API_URL_Sending.Value, 600)
	if err != nil {
		return "", err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Web_Service_API_URL_Sending.Modified+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Web_Service_API_URL_Sending.Modified exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Web_Service_API_URL_Receiving struct {
	Value    []byte
	Modified uint32
}

func (Web_Service_API_URL_Receiving *Web_Service_API_URL_Receiving) parse(input string) error {
	var err error
	var count int = 0
	Web_Service_API_URL_Receiving.Value, err = decodeToByte(input[count : count+600])
	count = count + 600
	if err != nil {
		return err
	}
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Web_Service_API_URL_Receiving.Modified = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Web_Service_API_URL_Receiving *Web_Service_API_URL_Receiving) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s, err = encodeFromByte(Web_Service_API_URL_Receiving.Value, 600)
	if err != nil {
		return "", err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Web_Service_API_URL_Receiving.Modified+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Web_Service_API_URL_Receiving.Modified exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Array struct {
	Value    []byte
	modified uint32
}

func (Array *Array) parse(input string) error {
	var err error
	var count int = 0
	Array.Value, err = decodeToByte(input[count : count+128])
	count = count + 128
	if err != nil {
		return err
	}
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Array.modified = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Array *Array) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s, err = encodeFromByte(Array.Value, 128)
	if err != nil {
		return "", err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Array.modified+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Array.modified exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Date struct {
	Year   uint32
	Month  uint32
	Day    uint32
	Minute uint32
}

func (Date *Date) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+7], 2, 32)
	Date.Year = uint32(num*1 - 0)
	count = count + 7
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+4], 2, 32)
	Date.Month = uint32(num*1 - 0)
	count = count + 4
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+5], 2, 32)
	Date.Day = uint32(num*1 - 0)
	count = count + 5
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+11], 2, 32)
	Date.Minute = uint32(num*1 - 0)
	count = count + 11
	if err != nil {
		return err
	}
	return err
}
func (Date *Date) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Date.Year+0)/1), 2), 7)
	if len(s) > 7 {
		err = errors.New("Value assigned for Date.Year exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Date.Month+0)/1), 2), 4)
	if len(s) > 4 {
		err = errors.New("Value assigned for Date.Month exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Date.Day+0)/1), 2), 5)
	if len(s) > 5 {
		err = errors.New("Value assigned for Date.Day exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Date.Minute+0)/1), 2), 11)
	if len(s) > 11 {
		err = errors.New("Value assigned for Date.Minute exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Date_Interval struct {
	Start Date
	Stop  Date
}

func (Date_Interval *Date_Interval) parse(input string) error {
	var err error
	var count int = 0
	Date_Interval.Start = *new(Date)
	err = Date_Interval.Start.parse(input[count : count+27])
	count = count + 27
	if err != nil {
		return err
	}
	Date_Interval.Stop = *new(Date)
	err = Date_Interval.Stop.parse(input[count : count+27])
	count = count + 27
	if err != nil {
		return err
	}
	return err
}
func (Date_Interval *Date_Interval) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s, err = Date_Interval.Start.encode()
	if err != nil {
		return "", err
	}
	str += s
	s, err = Date_Interval.Stop.encode()
	if err != nil {
		return "", err
	}
	str += s
	return str, err
}

type Position_Reporting_Interval_StoV struct {
	ValueInMn uint32
	To_Modify uint32
}

func (Position_Reporting_Interval_StoV *Position_Reporting_Interval_StoV) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+9], 2, 32)
	Position_Reporting_Interval_StoV.ValueInMn = uint32(num*5 - 0)
	count = count + 9
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Position_Reporting_Interval_StoV.To_Modify = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Position_Reporting_Interval_StoV *Position_Reporting_Interval_StoV) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Position_Reporting_Interval_StoV.ValueInMn+0)/5), 2), 9)
	if len(s) > 9 {
		err = errors.New("Value assigned for Position_Reporting_Interval_StoV.ValueInMn exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Position_Reporting_Interval_StoV.To_Modify+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Position_Reporting_Interval_StoV.To_Modify exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Geofencing_Enable_StoV struct {
	On_Off    uint32
	To_Modify uint32
}

func (Geofencing_Enable_StoV *Geofencing_Enable_StoV) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Geofencing_Enable_StoV.On_Off = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Geofencing_Enable_StoV.To_Modify = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Geofencing_Enable_StoV *Geofencing_Enable_StoV) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Geofencing_Enable_StoV.On_Off+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Geofencing_Enable_StoV.On_Off exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Geofencing_Enable_StoV.To_Modify+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Geofencing_Enable_StoV.To_Modify exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Geofence_Status_Check_Interval_StoV struct {
	ValueInMn uint32
	To_Modify uint32
}

func (Geofence_Status_Check_Interval_StoV *Geofence_Status_Check_Interval_StoV) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+9], 2, 32)
	Geofence_Status_Check_Interval_StoV.ValueInMn = uint32(num*5 - 0)
	count = count + 9
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Geofence_Status_Check_Interval_StoV.To_Modify = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Geofence_Status_Check_Interval_StoV *Geofence_Status_Check_Interval_StoV) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Geofence_Status_Check_Interval_StoV.ValueInMn+0)/5), 2), 9)
	if len(s) > 9 {
		err = errors.New("Value assigned for Geofence_Status_Check_Interval_StoV.ValueInMn exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Geofence_Status_Check_Interval_StoV.To_Modify+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Geofence_Status_Check_Interval_StoV.To_Modify exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Password_StoV struct {
	Value     []byte
	To_Modify uint32
}

func (Password_StoV *Password_StoV) parse(input string) error {
	var err error
	var count int = 0
	Password_StoV.Value, err = decodeToByte(input[count : count+120])
	count = count + 120
	if err != nil {
		return err
	}
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Password_StoV.To_Modify = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Password_StoV *Password_StoV) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s, err = encodeFromByte(Password_StoV.Value, 120)
	if err != nil {
		return "", err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Password_StoV.To_Modify+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Password_StoV.To_Modify exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Routing_StoV struct {
	Value     uint32
	To_Modify uint32
}

func (Routing_StoV *Routing_StoV) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+2], 2, 32)
	Routing_StoV.Value = uint32(num*1 - 0)
	count = count + 2
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Routing_StoV.To_Modify = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Routing_StoV *Routing_StoV) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Routing_StoV.Value+0)/1), 2), 2)
	if len(s) > 2 {
		err = errors.New("Value assigned for Routing_StoV.Value exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Routing_StoV.To_Modify+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Routing_StoV.To_Modify exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Web_Service_API_URL_sending_StoV struct {
	Value     []byte
	To_Modify uint32
}

func (Web_Service_API_URL_sending_StoV *Web_Service_API_URL_sending_StoV) parse(input string) error {
	var err error
	var count int = 0
	Web_Service_API_URL_sending_StoV.Value, err = decodeToByte(input[count : count+600])
	count = count + 600
	if err != nil {
		return err
	}
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Web_Service_API_URL_sending_StoV.To_Modify = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Web_Service_API_URL_sending_StoV *Web_Service_API_URL_sending_StoV) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s, err = encodeFromByte(Web_Service_API_URL_sending_StoV.Value, 600)
	if err != nil {
		return "", err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Web_Service_API_URL_sending_StoV.To_Modify+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Web_Service_API_URL_sending_StoV.To_Modify exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Web_Service_API_URL_Receiving_StoV struct {
	Value     []byte
	To_Modify uint32
}

func (Web_Service_API_URL_Receiving_StoV *Web_Service_API_URL_Receiving_StoV) parse(input string) error {
	var err error
	var count int = 0
	Web_Service_API_URL_Receiving_StoV.Value, err = decodeToByte(input[count : count+600])
	count = count + 600
	if err != nil {
		return err
	}
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Web_Service_API_URL_Receiving_StoV.To_Modify = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Web_Service_API_URL_Receiving_StoV *Web_Service_API_URL_Receiving_StoV) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s, err = encodeFromByte(Web_Service_API_URL_Receiving_StoV.Value, 600)
	if err != nil {
		return "", err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Web_Service_API_URL_Receiving_StoV.To_Modify+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Web_Service_API_URL_Receiving_StoV.To_Modify exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Array_StoV struct {
	Value     []byte
	To_Modify uint32
}

func (Array_StoV *Array_StoV) parse(input string) error {
	var err error
	var count int = 0
	Array_StoV.Value, err = decodeToByte(input[count : count+128])
	count = count + 128
	if err != nil {
		return err
	}
	var num uint64
	num, err = strconv.ParseUint(input[count:count+1], 2, 32)
	Array_StoV.To_Modify = uint32(num*1 - 0)
	count = count + 1
	if err != nil {
		return err
	}
	return err
}
func (Array_StoV *Array_StoV) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s, err = encodeFromByte(Array_StoV.Value, 128)
	if err != nil {
		return "", err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Array_StoV.To_Modify+0)/1), 2), 1)
	if len(s) > 1 {
		err = errors.New("Value assigned for Array_StoV.To_Modify exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Setting struct {
	New_Position_Report_Period uint32
	Speed_Threshold            float32
}

func (Setting *Setting) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+9], 2, 32)
	Setting.New_Position_Report_Period = uint32(num*5 - 0)
	count = count + 9
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	Setting.Speed_Threshold = float32(num)*0.1 - 0
	count = count + 8
	if err != nil {
		return err
	}
	return err
}
func (Setting *Setting) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Setting.New_Position_Report_Period+0)/5), 2), 9)
	if len(s) > 9 {
		err = errors.New("Value assigned for Setting.New_Position_Report_Period exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Setting.Speed_Threshold+0)/0.1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for Setting.Speed_Threshold exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Position struct {
	Longitude float32
	Latitude  float32
}

func (Position *Position) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+22], 2, 32)
	Position.Longitude = float32(num)*0.0001 - 180
	count = count + 22
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+21], 2, 32)
	Position.Latitude = float32(num)*0.0001 - 90
	count = count + 21
	if err != nil {
		return err
	}
	return err
}
func (Position *Position) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Position.Longitude+180)/0.0001), 2), 22)
	if len(s) > 22 {
		err = errors.New("Value assigned for Position.Longitude exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Position.Latitude+90)/0.0001), 2), 21)
	if len(s) > 21 {
		err = errors.New("Value assigned for Position.Latitude exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

type Position_Radius struct {
	Longitude float32
	Latitude  float32
	Radius    float32
}

func (Position_Radius *Position_Radius) parse(input string) error {
	var err error
	var count int = 0
	var num uint64
	num, err = strconv.ParseUint(input[count:count+22], 2, 32)
	Position_Radius.Longitude = float32(num)*0.0001 - 180
	count = count + 22
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+21], 2, 32)
	Position_Radius.Latitude = float32(num)*0.0001 - 90
	count = count + 21
	if err != nil {
		return err
	}
	num, err = strconv.ParseUint(input[count:count+11], 2, 32)
	Position_Radius.Radius = float32(num)*0.1 - 0
	count = count + 11
	if err != nil {
		return err
	}
	return err
}
func (Position_Radius *Position_Radius) encode() (string, error) {
	var str string = ""
	var s string
	var err error
	s = pad(strconv.FormatUint(uint64((Position_Radius.Longitude+180)/0.0001), 2), 22)
	if len(s) > 22 {
		err = errors.New("Value assigned for Position_Radius.Longitude exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Position_Radius.Latitude+90)/0.0001), 2), 21)
	if len(s) > 21 {
		err = errors.New("Value assigned for Position_Radius.Latitude exceeds limit")
		return str, err
	}
	str += s
	s = pad(strconv.FormatUint(uint64((Position_Radius.Radius+0)/0.1), 2), 11)
	if len(s) > 11 {
		err = errors.New("Value assigned for Position_Radius.Radius exceeds limit")
		return str, err
	}
	str += s
	return str, err
}

func pad(str string, length int) string {
	if len(str) >= length {
		return str
	}
	str = strings.Repeat("0", length-len(str)) + str
	return str
}

func decodeToByte(input string) ([]byte, error) {
	length := len(input)
	count := length / 8
	byteList := make([]byte, 0)
	var err error
	if count == 0 {
		return byteList, err
	}
	for i := 0; i < count; i++ {
		num, err := strconv.ParseUint(input[8*i:8+8*i], 2, 32)
		if err != nil {
			return byteList, err
		}
		if num == 0 {
			break
		}
		byteList = append(byteList, byte(num))
	}
	return byteList, err
}

func encodeFromByte(byteList []byte, size int) (string, error) {
	var str string = ""
	for _, b := range byteList {
		str += pad(strconv.FormatUint(uint64(b), 2), 8)
	}
	for i := 0; i < size-len(byteList)*8; i = i + 8 {
		str += "00100000"
	}
	return str, nil
}

func decToByte(input string) ([]byte, error) {
	length := len(input)
	count := length / 8
	byteList := make([]byte, count)
	var err error
	if count == 0 {
		return byteList, err
	}
	for i := 0; i < count; i++ {
		num, err := strconv.ParseUint(input[8*i:8+8*i], 2, 32)
		if err != nil {
			return byteList, err
		}
		byteList[i] = byte(num)
	}
	return byteList, err
}

func encFromByte(byteList []byte) (string, error) {
	var str string = ""
	for _, b := range byteList {
		str += pad(strconv.FormatUint(uint64(b), 2), 8)
	}
	return str, nil
}

func checkCRC(input string) error {
	dividend := input
	index := 0
	divisor := "100110001"
	for index < len(dividend)-8 {
		if dividend[index] == '1' {
			dividend = divide(dividend, divisor, index)
		}
		index++
	}
	if dividend[len(dividend)-8:] != "00000000" {
		err := errors.New("CRC check failed for input string")
		return err
	}
	return nil
}

func attachCRC(input string) string {
	dividend := input[:len(input)-8]
	result := dividend
	dividend = dividend + "00000000"
	index := 0
	divisor := "100110001"
	for index < len(dividend)-8 {
		if dividend[index] == '1' {
			dividend = divide(dividend, divisor, index)
		}
		index++
	}
	result = result + dividend[len(dividend)-8:]
	return result
}

func divide(dividend string, divisor string, index int) string {
	var buffer bytes.Buffer
	for i := index; i < index+9; i++ {
		if dividend[i] == divisor[i-index] {
			buffer.WriteString("0")
		} else {
			buffer.WriteString("1")
		}
	}
	return dividend[:index] + buffer.String() + dividend[index+9:]
}

type Omnicom interface {
	Parse(string) error
	Encode() ([]byte, error)
	getHeader() byte
	getCRC() uint32
	setCRC(uint32)
}

func Parse(input []byte) (Omnicom, error) {
	var err error
	err = errors.New("No messages match")
	str, _ := encFromByte(input)
	//err = checkCRC(str)
	//if err != nil {
	//        return nil, err
	//}
	switch str[0:8] {
	case "00001010":
		SPRS := new(SPRS)
		err := SPRS.Parse(str)
		if err != nil {
			return nil, err
		}
		SPRS.Header = input[0]
		return SPRS, err
	case "00111000":
		BM_StoV := new(BM_StoV)
		err := BM_StoV.Parse(str)
		if err != nil {
			return nil, err
		}
		BM_StoV.Header = input[0]
		return BM_StoV, err
	case "01000000":
		SPM := new(SPM)
		err := SPM.Parse(str)
		if err != nil {
			return nil, err
		}
		SPM.Header = input[0]
		return SPM, err
	case "00000010":
		AR := new(AR)
		err := AR.Parse(str)
		if err != nil {
			return nil, err
		}
		AR.Header = input[0]
		return AR, err
	case "00000011":
		GP := new(GP)
		err := GP.Parse(str)
		if err != nil {
			return nil, err
		}
		GP.Header = input[0]
		return GP, err
	case "00001000":
		AUP := new(AUP)
		err := AUP.Parse(str)
		if err != nil {
			return nil, err
		}
		AUP.Header = input[0]
		return AUP, err
	case "00000111":
		BM := new(BM)
		err := BM.Parse(str)
		if err != nil {
			return nil, err
		}
		BM.Header = input[0]
		return BM, err
	case "00110010":
		UIC := new(UIC)
		err := UIC.Parse(str)
		if err != nil {
			return nil, err
		}
		UIC.Header = input[0]
		return UIC, err
	case "00110101":
		if str[79:79+1] == "0" {

			UG_Polygon := new(UG_Polygon)
			err := UG_Polygon.Parse(str)
			if err != nil {
				return nil, err
			}
			UG_Polygon.Header = input[0]
			return UG_Polygon, err
		}
		if str[79:79+1] == "1" {

			UG_Circle := new(UG_Circle)
			err := UG_Circle.Parse(str)
			if err != nil {
				return nil, err
			}
			UG_Circle.Header = input[0]
			return UG_Circle, err
		}
	case "00000110":
		SPR := new(SPR)
		err := SPR.Parse(str)
		if err != nil {
			return nil, err
		}
		SPR.Header = input[0]
		return SPR, err
	case "00110001":
		RMH := new(RMH)
		err := RMH.Parse(str)
		if err != nil {
			return nil, err
		}
		RMH.Header = input[0]
		return RMH, err
	case "00111010":
		UAUP := new(UAUP)
		err := UAUP.Parse(str)
		if err != nil {
			return nil, err
		}
		UAUP.Header = input[0]
		return UAUP, err
	case "00110111":
		DG := new(DG)
		err := DG.Parse(str)
		if err != nil {
			return nil, err
		}
		DG.Header = input[0]
		return DG, err
	case "00111001":
		UF := new(UF)
		err := UF.Parse(str)
		if err != nil {
			return nil, err
		}
		UF.Header = input[0]
		return UF, err
	case "00110100":
		UGP := new(UGP)
		err := UGP.Parse(str)
		if err != nil {
			return nil, err
		}
		UGP.Header = input[0]
		return UGP, err
	case "00110110":
		GBMN := new(GBMN)
		err := GBMN.Parse(str)
		if err != nil {
			return nil, err
		}
		GBMN.Header = input[0]
		return GBMN, err
	case "00000001":
		HPR := new(HPR)
		err := HPR.Parse(str)
		if err != nil {
			return nil, err
		}
		HPR.Header = input[0]
		return HPR, err
	case "00000100":
		GA := new(GA)
		err := GA.Parse(str)
		if err != nil {
			return nil, err
		}
		GA.Header = input[0]
		return GA, err
	case "00001001":
		ABM := new(ABM)
		err := ABM.Parse(str)
		if err != nil {
			return nil, err
		}
		ABM.Header = input[0]
		return ABM, err
	case "00110000":
		TMA := new(TMA)
		err := TMA.Parse(str)
		if err != nil {
			return nil, err
		}
		TMA.Header = input[0]
		return TMA, err
	case "01000101":
		AA := new(AA)
		err := AA.Parse(str)
		if err != nil {
			return nil, err
		}
		AA.Header = input[0]
		return AA, err
	case "00110011":
		RSM := new(RSM)
		err := RSM.Parse(str)
		if err != nil {
			return nil, err
		}
		RSM.Header = input[0]
		return RSM, err
	case "01000001":
		SDR := new(SDR)
		err := SDR.Parse(str)
		if err != nil {
			return nil, err
		}
		SDR.Header = input[0]
		return SDR, err
	case "00000101":
		SMDR := new(SMDR)
		err := SMDR.Parse(str)
		if err != nil {
			return nil, err
		}
		SMDR.Header = input[0]
		return SMDR, err
	}
	return nil, err
}
