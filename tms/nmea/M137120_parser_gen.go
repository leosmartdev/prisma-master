// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strconv"
import "strings"

// M137120 represents fix data.
type CoreM137120 struct {
	MessageID uint8

	RepeatIndicator uint32

	Mmsi uint32

	Spare1 uint32 //Supposed to be Unknown

	Offset1 uint32

	SlotCount1 uint32

	Timeout1 uint32

	Increment1 uint32

	Offset2 uint32

	Slotcount2 uint32

	Timeout2 uint32

	Increment2 uint32

	Offset3 uint32

	SlotCount3 uint32

	Timeout3 uint32

	Increment3 uint32

	Offset4 uint32

	SlotCount4 uint32

	Timeout4 uint32

	Increment4 uint32

	Spare2 uint32 //Supposed to be Unknown
}
type M137120 struct {
	VDMO
	CoreM137120
}

func NewM137120(sentence VDMO) *M137120 {
	s := new(M137120)
	s.VDMO = sentence
	return s
}

func (s *M137120) parse() error {
	var err error

	if MessageType(s.EncapData) != 20 {
		err = fmt.Errorf("message %d is not a M137120", MessageType(s.EncapData))
		return err
	}

	data := []byte(s.EncapData)

	//if len(data)*6 > 166 {
	//	err = fmt.Errorf("Message lenght is larger than it should be [%d!=166]", len(data)*6)
	//	return err
	//}

	s.MessageID = MessageType(s.EncapData)

	s.CoreM137120.RepeatIndicator = BitsToInt(6, 7, data)

	s.CoreM137120.Mmsi = BitsToInt(8, 37, data)

	s.CoreM137120.Spare1 = BitsToInt(38, 39, data)

	s.CoreM137120.Offset1 = BitsToInt(40, 51, data)

	s.CoreM137120.SlotCount1 = BitsToInt(52, 55, data)

	s.CoreM137120.Timeout1 = BitsToInt(56, 58, data)

	s.CoreM137120.Increment1 = BitsToInt(59, 69, data)

	s.CoreM137120.Offset2 = BitsToInt(70, 81, data)

	s.CoreM137120.Slotcount2 = BitsToInt(82, 85, data)

	s.CoreM137120.Timeout2 = BitsToInt(86, 88, data)

	s.CoreM137120.Increment2 = BitsToInt(89, 99, data)

	s.CoreM137120.Offset3 = BitsToInt(100, 111, data)

	s.CoreM137120.SlotCount3 = BitsToInt(112, 115, data)

	s.CoreM137120.Timeout3 = BitsToInt(116, 118, data)

	s.CoreM137120.Increment3 = BitsToInt(119, 129, data)

	s.CoreM137120.Offset4 = BitsToInt(130, 141, data)

	s.CoreM137120.SlotCount4 = BitsToInt(142, 145, data)

	s.CoreM137120.Timeout4 = BitsToInt(146, 148, data)

	s.CoreM137120.Increment4 = BitsToInt(149, 159, data)

	s.CoreM137120.Spare2 = BitsToInt(160, 6*(len(data)-1), data)

	return nil
}

func (s *M137120) Encode() (string, error) {
	var Raw string
	var Sbinary string

	if s.MessageID != 20 {
		err := fmt.Errorf("message %d is not a M137120", s.MessageID)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format + ","

	if s.SentenceCountValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SentenceCount), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.SentenceIndexValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SentenceIndex), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.SeqMsgIDValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.SeqMsgID), 10) + ","
	} else {
		Raw = Raw + ","
	}

	if s.ChannelValidity == true {
		Raw = Raw + s.Channel
	}

	str := strconv.FormatInt(int64(s.CoreM137120.MessageID), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.RepeatIndicator), 2)
	for len(str) < 2 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Mmsi), 2)
	for len(str) < 30 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Spare1), 2)
	for len(str) < 2 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Offset1), 2)
	for len(str) < 12 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.SlotCount1), 2)
	for len(str) < 4 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Timeout1), 2)
	for len(str) < 3 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Increment1), 2)
	for len(str) < 11 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Offset2), 2)
	for len(str) < 12 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Slotcount2), 2)
	for len(str) < 4 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Timeout2), 2)
	for len(str) < 3 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Increment2), 2)
	for len(str) < 11 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Offset3), 2)
	for len(str) < 12 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.SlotCount3), 2)
	for len(str) < 4 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Timeout3), 2)
	for len(str) < 3 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Increment3), 2)
	for len(str) < 11 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Offset4), 2)
	for len(str) < 12 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.SlotCount4), 2)
	for len(str) < 4 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Timeout4), 2)
	for len(str) < 3 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Increment4), 2)
	for len(str) < 11 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	str = strconv.FormatInt(int64(s.CoreM137120.Spare2), 2)
	for len(str) < 6 {
		str = "0" + str
	}
	Sbinary = Sbinary + str

	field := strings.SplitN(Sbinary, "", len(Sbinary))

	var encdata = make([]string, int((len(Sbinary)+int(s.FillBits))/6))

	j := 0
	for i := 0; i < int((len(Sbinary)+int(s.FillBits))/6); i++ {

		if i == (int((len(Sbinary)+int(s.FillBits))/6) - 1) {
			for j < len(Sbinary) {
				encdata[i] = encdata[i] + field[j]
				j = j + 1
			}
			for h := 0; h < int(s.FillBits); h++ {
				encdata[i] = encdata[i] + "0" // fill bits
			}
		} else {
			encdata[i] = field[j] + field[j+1] + field[j+2] + field[j+3] + field[j+4] + field[j+5]
			j = j + 6
		}
	}

	var data string
	for j := 0; j < int((len(Sbinary)+int(s.FillBits))/6); j++ {
		i, _ := strconv.ParseInt(encdata[j], 2, 8)
		if i < 40 {
			i = i + 48
		} else {
			i = i + 8 + 48
		}
		data = data + string(rune(i))
	}

	Raw = Raw + "," + data + ","

	if s.FillBitsValidity == true {
		Raw = Raw + strconv.FormatInt(int64(s.FillBits), 10)
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
