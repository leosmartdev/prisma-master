package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

//Generator for accumulated output.
type Generator struct {
	buf bytes.Buffer
}

//Message represents the omnicom sentence definition structure
type Message struct {
	Name      string
	Type      string
	Introduct string
	HeaderStr string
	Ident     string
	Index     int
	Fields    []Field
	Size      int
}

type Field struct {
	Name      string
	Repeated  int
	Type      string
	Fields    []Field
	Size      int
	Reference string
	Offset    string
	Scale     string
}

var (
	//Path default value set according to the prisma project structure
	Path = flag.String("path", "../../../omnicom/", "-path=/path/to/omnicom path to omnicom library directory")

	mapDef     map[string]int
	mapParser  map[string]int
	mapEncoder map[string]int
	mapHeader  map[string][]Message
)

func jsonParse(filename string) []Message {

	file, e := ioutil.ReadFile(filename)
	if e != nil {
		fmt.Printf("File error: %v\n", e)
		os.Exit(1)
	}

	var jsontype []Message
	json.Unmarshal(file, &jsontype)

	return jsontype
}

/*
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}
*/

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func main() {
	mapDef = make(map[string]int)
	mapParser = make(map[string]int)
	mapEncoder = make(map[string]int)
	mapHeader = make(map[string][]Message)
	//log.SetFlags(0)
	//log.SetPrefix("generator: ")

	flag.Parse()

	//messageArray := jsonParse(*File)
	messagesArray := jsonParse("./Messages.json")
	var pg Generator

	pg.Printf("// Code generated by omnicom; DO NOT EDIT \n")
	pg.Printf("package omnicom\n")
	pg.Printf("import ( \n")
	pg.Printf("\"strconv\"\n")
	pg.Printf("\"strings\"\n")
	pg.Printf("\"bytes\"\n")
	pg.Printf("\"errors\"\n")
	pg.Printf(")\n")
	for _, message := range messagesArray {

		var g Generator
		g.Printf("//%s\n", message.Introduct)
		g.Printf("// Code generated by omnicom; DO NOT EDIT \n")
		g.Printf("package omnicom\n")
		g.Printf("import ( \n")
		g.Printf("\"errors\"\n")
		g.Printf("\"strconv\"\n")
		g.Printf(")\n")

		if message.Name == "" {
			message.Name = message.Type //strings.ToLower(message.Type)
		}

		_, exist := mapHeader[message.HeaderStr]
		if exist {
			mapHeader[message.HeaderStr] = append(mapHeader[message.HeaderStr], message)
		} else {
			mapHeader[message.HeaderStr] = make([]Message, 0)
			mapHeader[message.HeaderStr] = append(mapHeader[message.HeaderStr], message)
		}

		g.printMessageDef(message)
		g.printMessageParser(message)
		g.printMessageEncoder(message)

		for _, t := range message.Fields {
			if t.Repeated == 0 {
				t.Repeated = 1
			}
			t.Name = t.Type
			if t.Type != "float32" && t.Type != "uint32" && t.Type != "[]byte" && t.Type != "byte" && t.Type != "int32" && t.Type != "int" && t.Type != "uint64" && t.Type != "string" {
				pg.printFieldDef(t)
				pg.printFieldParser(t)
				pg.printFieldEncoder(t)
			}
		}

		g.Printf("func (%s *%s)getHeader() byte {\n", message.Name, message.Type)
		g.Printf("return %s.Header\n", message.Name)
		g.Printf("}\n")

		g.Printf("func (%s *%s)getCRC() uint32 {\n", message.Name, message.Type)
		g.Printf("return %s.CRC\n", message.Name)
		g.Printf("}\n")

		g.Printf("func (%s *%s)setCRC(crc uint32) {\n", message.Name, message.Type)
		g.Printf("%s.CRC = crc \n", message.Name)
		g.Printf("}\n")

		//src := g.format()
		src_msg := g.buf.Bytes()
		//fmt.Println(src)
		err := ioutil.WriteFile(*Path+message.Type+".go", src_msg, 0644)
		if err != nil {
			fmt.Printf("writing output: %s", err)

		}
	}
	pg.Printf(padFunc)
	pg.Printf(decodeByteFunc)
	pg.Printf(encodeByteFunc)
	pg.Printf(decByteFunc)
	pg.Printf(encByteFunc)
	pg.Printf(checkFunc)
	pg.Printf(attachFunc)
	pg.Printf(divideFunc)
	pg.Printf(omnicomInterface)
	pg.Printf(parseFuncHead)

	for header := range mapHeader {
		pg.Printf("case \"%s\":", header)
		if len(mapHeader[header]) == 1 {
			msgs := mapHeader[header]
			msg := msgs[0]
			pg.Printf(parseFuncCase, msg.Name, msg.Type, msg.Name, msg.Name, msg.Name)
		} else {
			msgs := mapHeader[header]
			for _, msg := range msgs {
				pg.Printf("if str[%d:%d+%d] == \"%s\" {\n", msg.Index, msg.Index, len(msg.Ident), msg.Ident)
				pg.Printf(parseFuncCase, msg.Name, msg.Type, msg.Name, msg.Name, msg.Name)
				pg.Printf("}\n")
			}
		}
	}

	pg.Printf("}\n")
	pg.Printf("return nil, err\n")
	pg.Printf("}\n")

	//src_parse := pg.format()
	src_parse := pg.buf.Bytes()
	//fmt.Println(src)
	err := ioutil.WriteFile(*Path+"Omnicom.go", src_parse, 0644)
	if err != nil {
		fmt.Printf("writing output: %s", err)

	}
}

func (pg *Generator) printFieldDef(field Field) {
	_, exist := mapDef[field.Type]
	if exist {
		return
	}
	mapDef[field.Type] = 1
	field.Name = field.Type
	pg.Printf("type %s  struct {\n", field.Type)
	for _, t := range field.Fields {
		if t.Repeated == 0 {
			t.Repeated = 1
		}
		if t.Type != "float32" && t.Type != "uint32" && t.Type != "uint64" && t.Type != "[]byte" && t.Type != "byte" && t.Type != "int32" && t.Type != "int" && t.Type != "string" {
			defer pg.printFieldDef(t)
		}
		if t.Repeated > 1 {
			pg.Printf("%s   []%s\n", t.Name, t.Type)
		} else {
			pg.Printf("%s    %s\n", t.Name, t.Type)
		}
	}
	pg.Printf("}\n")
}

func (pg *Generator) printFieldParser(field Field) {
	_, exist := mapParser[field.Type]
	if exist {
		return
	}
	mapParser[field.Type] = 1
	pg.Printf("func (%s *%s)parse(input string) error {\n", field.Name, field.Type)
	pg.Printf("var  err error\n")
	pg.Printf("var  count int = 0\n")

	needNum := true
	for _, t := range field.Fields {
		if t.Repeated > 1 {
			if t.Reference != "" {
				pg.Printf("%s.%s = make([]%s, int(%s.%s))\n", field.Name, t.Name, t.Type, field.Name, t.Reference)
				pg.Printf("for i := 0; i < int(%s.%s); i++ {\n", field.Name, t.Reference)
			} else {
				pg.Printf("%s.%s = make([]%s, %d)\n", field.Name, t.Name, t.Type, t.Repeated)
				pg.Printf("for i := 0; i < %d; i++ {\n", t.Repeated)
			}
		}
		if t.Type == "uint32" {
			if t.Scale == "" {
				t.Scale = "1"
			}
			if t.Offset == "" {
				t.Offset = "0"
			}
			if needNum {
				pg.Printf("var num uint64\n")
			}
			needNum = false

			pg.Printf("num, err = strconv.ParseUint(input[count:count+%d], 2, 32)\n", t.Size)
			pg.Printf("%s.%s = uint32(num * %s - %s)\n", field.Name, t.Name, t.Scale, t.Offset)
			pg.Printf("count = count + %d\n", t.Size)

			pg.Printf("if err != nil {\n")
			pg.Printf("return err\n")
			pg.Printf("}\n")
		} else if t.Type == "uint64" {
			if t.Scale == "" {
				t.Scale = "1"
			}
			if t.Offset == "" {
				t.Offset = "0"
			}
			if needNum {
				pg.Printf("var num uint64\n")
			}
			needNum = false

			pg.Printf("num, err = strconv.ParseUint(input[count:count+%d], 2, 32)\n", t.Size)
			pg.Printf("%s.%s = num * %s - %s\n", field.Name, t.Name, t.Scale, t.Offset)
			pg.Printf("count = count + %d\n", t.Size)

			pg.Printf("if err != nil {\n")
			pg.Printf("return err\n")
			pg.Printf("}\n")
		} else if t.Type == "float32" {
			if t.Scale == "" {
				t.Scale = "1"
			}
			if t.Offset == "" {
				t.Offset = "0"
			}
			if needNum {
				pg.Printf("var num uint64\n")
			}
			needNum = false

			pg.Printf("num, err = strconv.ParseUint(input[count:count+%d], 2, 32)\n", t.Size)
			pg.Printf("%s.%s = float32(num) * %s - %s\n", field.Name, t.Name, t.Scale, t.Offset)
			pg.Printf("count = count + %d\n", t.Size)

			pg.Printf("if err != nil {\n")
			pg.Printf("return err\n")
			pg.Printf("}\n")
		} else if t.Type == "[]byte" {

			pg.Printf("%s.%s, err = decodeToByte(input[count:count+%d])\n", field.Name, t.Name, t.Size)
			pg.Printf("count = count + %d\n", t.Size)

			pg.Printf("if err != nil {\n")
			pg.Printf("return err\n")
			pg.Printf("}\n")
		} else if t.Type == "string" {
			if t.Reference != "" {
				pg.Printf("%s.%s = input[count:count+int(%s.%s) * 8]\n", field.Name, t.Name, field.Name, t.Reference)
				pg.Printf("count = count + int(%s.%s) * 8\n", field.Name, t.Reference)
				pg.Printf("if %d < int(%s.%s) * 8 {\n", t.Size, field.Name, t.Reference)
				pg.Printf("err = errors.New(\"%s.%s is larger than limit\")\n", field.Name, t.Reference)
				pg.Printf("return err }\n")
			} else {
				pg.Printf("%s.%s = input[count:count+%d]\n", field.Name, t.Name, t.Size)
				pg.Printf("count = count + %d\n", t.Size)
			}

		} else {
			defer pg.printFieldParser(t)
			if t.Repeated > 1 {
				pg.Printf("%s.%s[i] = *new (%s)\n", field.Name, t.Name, t.Type)
				pg.Printf("err = %s.%s[i].parse(input[count:count+%d])\n", field.Name, t.Name, t.Size)
				pg.Printf("count = count + %d\n", t.Size)
			} else {
				pg.Printf("%s.%s = *new (%s)\n", field.Name, t.Name, t.Type)
				pg.Printf("err = %s.%s.parse(input[count:count+%d])\n", field.Name, t.Name, t.Size)
				pg.Printf("count = count + %d\n", t.Size)
			}
			pg.Printf("if err != nil {\n")
			pg.Printf("return err\n")
			pg.Printf("}\n")
		}
		if t.Repeated > 1 {
			pg.Printf("}\n")
		}
	}
	pg.Printf("return err\n")
	pg.Printf("}\n")
}

func (pg *Generator) printFieldEncoder(field Field) {
	_, exist := mapEncoder[field.Type]
	if exist {
		return
	}
	mapEncoder[field.Type] = 1
	pg.Printf("func (%s *%s)encode() (string, error) {\n", field.Name, field.Type)
	pg.Printf("var str string = \"\"\n")
	pg.Printf("var s string\n")
	pg.Printf("var  err error\n")
	for _, t := range field.Fields {
		if t.Repeated > 1 {
			if t.Reference != "" {
				pg.Printf("for i := 0; i < int(%s.%s); i++ {\n", field.Name, t.Reference)
			} else {
				pg.Printf("for i := 0; i < %d; i++ {\n", t.Repeated)
			}
		}
		if t.Type == "uint32" {
			if t.Scale == "" {
				t.Scale = "1"
			}
			if t.Offset == "" {
				t.Offset = "0"
			}

			pg.Printf("s = pad(strconv.FormatUint(uint64((%s.%s + %s) / %s), 2), %d)\n", field.Name, t.Name, t.Offset, t.Scale, t.Size)
			pg.Printf("if len(s) > %d {\n", t.Size)
			pg.Printf("err = errors.New(\"Value assigned for %s.%s exceeds limit\")\n", field.Name, t.Name)
			pg.Printf("return str, err\n")
			pg.Printf("}\n")
			pg.Printf("str += s\n")

		} else if t.Type == "uint64" {
			if t.Scale == "" {
				t.Scale = "1"
			}
			if t.Offset == "" {
				t.Offset = "0"
			}

			pg.Printf("s = pad(strconv.FormatUint(((%s.%s + %s) / %s), 2), %d)\n", field.Name, t.Name, t.Offset, t.Scale, t.Size)
			pg.Printf("if len(s) > %d {\n", t.Size)
			pg.Printf("err = errors.New(\"Value assigned for %s.%s exceeds limit\")\n", field.Name, t.Name)
			pg.Printf("return str, err\n")
			pg.Printf("}\n")
			pg.Printf("str += s\n")

		} else if t.Type == "float32" {
			if t.Scale == "" {
				t.Scale = "1"
			}
			if t.Offset == "" {
				t.Offset = "0"
			}

			pg.Printf("s = pad(strconv.FormatUint(uint64((%s.%s + %s) / %s), 2), %d)\n", field.Name, t.Name, t.Offset, t.Scale, t.Size)
			pg.Printf("if len(s) > %d {\n", t.Size)
			pg.Printf("err = errors.New(\"Value assigned for %s.%s exceeds limit\")\n", field.Name, t.Name)
			pg.Printf("return str, err\n")
			pg.Printf("}\n")
			pg.Printf("str += s\n")

		} else if t.Type == "[]byte" {
			pg.Printf("s, err = encodeFromByte(%s.%s, %d)\n", field.Name, t.Name, t.Size)
			pg.Printf("if err != nil {\n")
			pg.Printf("return \"\", err\n")
			pg.Printf("}\n")
			pg.Printf("str += s\n")
		} else if t.Type == "string" {
			pg.Printf("str += %s.%s\n", field.Name, t.Name)
		} else {
			defer pg.printFieldEncoder(t)
			if t.Repeated > 1 {
				pg.Printf("s, err = %s.%s[i].encode()\n", field.Name, t.Name)
			} else {
				pg.Printf("s, err = %s.%s.encode()\n", field.Name, t.Name)
			}
			pg.Printf("if err != nil {\n")
			pg.Printf("return \"\", err\n")
			pg.Printf("}\n")
			pg.Printf("str += s\n")
		}
		if t.Repeated > 1 {
			pg.Printf("}\n")
		}
	}
	pg.Printf("return str, err\n")
	pg.Printf("}\n")
}

func (g *Generator) printMessageDef(message Message) {
	g.Printf("type %s  struct {\n", message.Type)
	for _, t := range message.Fields {
		if t.Repeated == 0 {
			t.Repeated = 1
		}
		if t.Repeated > 1 {
			g.Printf("%s    []%s\n", t.Name, t.Type)
		} else {
			g.Printf("%s    %s\n", t.Name, t.Type)
		}
	}
	g.Printf("}\n")
}

func (g *Generator) printMessageParser(message Message) {
	g.Printf("func (%s *%s)Parse(input string) error {\n", message.Name, message.Type)
	g.Printf("var  err error\n")
	if message.Size > 0 {
		g.Printf("if len(input) > %d {\n", message.Size)
		g.Printf("err = errors.New(\"Input message is longer than limit\")\n")
		g.Printf("return err\n")
		g.Printf("}\n")
	}
	g.Printf("var  count int = 0\n")
	needNum := true

	for i := 0; i < len(message.Fields); i++ {
		if strings.HasPrefix(message.Fields[i].Name, "Extention_Bit") && message.Fields[i].Type == "uint32" {
			needNum = g.parseField(message.Fields[i], message.Name, needNum)
			g.Printf("if %s.%s == 1 {\n", message.Name, message.Fields[i].Name)
			i++
			needNum = g.parseField(message.Fields[i], message.Name, needNum)
			g.Printf("}\n")
		} else {
			needNum = g.parseField(message.Fields[i], message.Name, needNum)
		}

	}
	g.Printf("return err\n")
	g.Printf("}\n")
}

func (g *Generator) parseField(t Field, name string, needNum bool) bool {
	if t.Repeated > 1 {
		if t.Reference != "" {
			g.Printf("%s.%s = make([]%s, int(%s.%s))\n", name, t.Name, t.Type, name, t.Reference)
			g.Printf("for i := 0; i < int(%s.%s); i++ {\n", name, t.Reference)
		} else {
			g.Printf("%s.%s = make([]%s, %d)\n", name, t.Name, t.Type, t.Repeated)
			g.Printf("for i := 0; i < %d; i++ {\n", t.Repeated)
		}
	}

	if t.Name == "Padding" && t.Type == "uint32" {
		if t.Scale == "" {
			t.Scale = "1"
		}
		if t.Offset == "" {
			t.Offset = "0"
		}
		if needNum {
			g.Printf("var num uint64\n")
		}

		g.Printf("if count + (8- count%%8) > len(input) {\n")
		g.Printf("err = errors.New(\"Input message length of %s is shorter than required\")\n", name)
		g.Printf("return err\n")
		g.Printf("}\n")

		g.Printf("num, err = strconv.ParseUint(input[count:count+(8 - count%%8)], 2, 32)\n")
		g.Printf("%s.%s = uint32(num * %s - %s)\n", name, t.Name, t.Scale, t.Offset)
		g.Printf("count = count + (8 - count%%8)\n")

		g.Printf("if err != nil {\n")
		g.Printf("return err\n")
		g.Printf("}\n")
		return false
	}

	if t.Type == "uint32" {
		if t.Scale == "" {
			t.Scale = "1"
		}
		if t.Offset == "" {
			t.Offset = "0"
		}
		if needNum {
			g.Printf("var num uint64\n")
		}

		g.Printf("if count + %d > len(input) {\n", t.Size)
		g.Printf("err = errors.New(\"Input message length of %s is shorter than required\")\n", name)
		g.Printf("return err\n")
		g.Printf("}\n")

		g.Printf("num, err = strconv.ParseUint(input[count:count+%d], 2, 32)\n", t.Size)
		g.Printf("%s.%s = uint32(num * %s - %s)\n", name, t.Name, t.Scale, t.Offset)
		g.Printf("count = count + %d\n", t.Size)

		g.Printf("if err != nil {\n")
		g.Printf("return err\n")
		g.Printf("}\n")
		if t.Repeated > 1 {
			g.Printf("}\n")
		}
		return false
	}
	if t.Type == "uint64" {
		if t.Scale == "" {
			t.Scale = "1"
		}
		if t.Offset == "" {
			t.Offset = "0"
		}
		if needNum {
			g.Printf("var num uint64\n")
		}

		g.Printf("if count + %d > len(input) {\n", t.Size)
		g.Printf("err = errors.New(\"Input message length of %s is shorter than required\")\n", name)
		g.Printf("return err\n")
		g.Printf("}\n")

		g.Printf("num, err = strconv.ParseUint(input[count:count+%d], 2, 32)\n", t.Size)
		g.Printf("%s.%s = num * %s - %s\n", name, t.Name, t.Scale, t.Offset)
		g.Printf("count = count + %d\n", t.Size)

		g.Printf("if err != nil {\n")
		g.Printf("return err\n")
		g.Printf("}\n")
		if t.Repeated > 1 {
			g.Printf("}\n")
		}
		return false
	}
	if t.Type == "byte" {
		g.Printf("if count + %d > len(input) {\n", t.Size)
		g.Printf("err = errors.New(\"Input message length of %s is shorter than required\")\n", name)
		g.Printf("return err\n")
		g.Printf("}\n")

		g.Printf("count = count + %d\n", t.Size)
		if t.Repeated > 1 {
			g.Printf("}\n")
		}
		return needNum
	}
	if t.Type == "float32" {
		if t.Scale == "" {
			t.Scale = "1"
		}
		if t.Offset == "" {
			t.Offset = "0"
		}
		if needNum {
			g.Printf("var num uint64\n")
		}

		g.Printf("if count + %d > len(input) {\n", t.Size)
		g.Printf("err = errors.New(\"Input message length of %s is shorter than required\")\n", name)
		g.Printf("return err\n")
		g.Printf("}\n")

		g.Printf("num, err = strconv.ParseUint(input[count:count+%d], 2, 32)\n", t.Size)
		g.Printf("%s.%s = float32(num) * float32(%s) - float32(%s)\n", name, t.Name, t.Scale, t.Offset)
		g.Printf("count = count + %d\n", t.Size)

		g.Printf("if err != nil {\n")
		g.Printf("return err\n")
		g.Printf("}\n")
		if t.Repeated > 1 {
			g.Printf("}\n")
		}
		return false
	}
	if t.Type == "[]byte" {
		if t.Reference != "" {
			g.Printf("if count + int(%s.%s) * 8 > len(input) {\n", name, t.Reference)
			g.Printf("err = errors.New(\"Input message length of %s is shorter than required\")\n", name)
			g.Printf("return err\n")
			g.Printf("}\n")

			g.Printf("if %d < int(%s.%s) * 8 {\n", t.Size, name, t.Reference)
			g.Printf("err = errors.New(\"%s.%s is larger than limit\")\n", name, t.Reference)
			g.Printf("return err }\n")

			g.Printf("%s.%s, err = decodeToByte(input[count:count+int(%s.%s) * 8])\n", name, t.Name, name, t.Reference)
			g.Printf("count = count + int(%s.%s) * 8\n", name, t.Reference)
		} else {
			g.Printf("if count + %d > len(input) {\n", t.Size)
			g.Printf("err = errors.New(\"Input message length of %s is shorter than required\")\n", name)
			g.Printf("return err\n")
			g.Printf("}\n")

			g.Printf("%s.%s, err = decodeToByte(input[count:count+%d])\n", name, t.Name, t.Size)
			g.Printf("count = count + %d\n", t.Size)
		}
		g.Printf("if err != nil {\n")
		g.Printf("return err\n")
		g.Printf("}\n")
		if t.Repeated > 1 {
			g.Printf("}\n")
		}
		return needNum
	}

	g.Printf("if count + %d > len(input) {\n", t.Size)
	g.Printf("err = errors.New(\"Input message length of %s is shorter than required\")\n", name)
	g.Printf("return err\n")
	g.Printf("}\n")

	if t.Repeated > 1 {
		g.Printf("%s.%s[i] = *new (%s)\n", name, t.Name, t.Type)
		g.Printf("err = %s.%s[i].parse(input[count:count+%d])\n", name, t.Name, t.Size)
		g.Printf("count = count + %d\n", t.Size)
	} else {
		g.Printf("%s.%s = *new (%s)\n", name, t.Name, t.Type)
		g.Printf("err = %s.%s.parse(input[count:count+%d])\n", name, t.Name, t.Size)
		g.Printf("count = count + %d\n", t.Size)
	}
	g.Printf("if err != nil {\n")
	g.Printf("return err\n")
	g.Printf("}\n")
	if t.Repeated > 1 {
		g.Printf("}\n")
	}
	return needNum
}

func (g *Generator) printMessageEncoder(message Message) {
	g.Printf("func (%s *%s)Encode() ([]byte, error) {\n", message.Name, message.Type)
	g.Printf("var str string\n")
	g.Printf("var s string\n")
	g.Printf("var  err error\n")
	for i := 0; i < len(message.Fields); i++ {
		if strings.HasPrefix(message.Fields[i].Name, "Extention_Bit") && message.Fields[i].Type == "uint32" {
			g.encodeField(message.Fields[i], message.Name)
			g.Printf("if %s.%s == 1 {\n", message.Name, message.Fields[i].Name)
			i++
			g.encodeField(message.Fields[i], message.Name)
			g.Printf("}\n")
		} else {
			g.encodeField(message.Fields[i], message.Name)
		}
	}
	g.Printf("str = attachCRC(str)\n")
	g.Printf("byteList, err := decToByte(str)\n")
	//g.Printf("return append([]byte{%s.Header}, byteList...), err\n", message.Name)
	g.Printf("return byteList, err\n")
	g.Printf("}\n")
}

func (g *Generator) encodeField(t Field, name string) {

	if t.Repeated > 1 {
		if t.Reference != "" {
			g.Printf("for i := 0; i < int(%s.%s); i++ {\n", name, t.Reference)
		} else {
			g.Printf("for i := 0; i < %d; i++ {\n", t.Repeated)
		}
	}
	if t.Name == "Padding" && t.Type == "uint32" {
		if t.Scale == "" {
			t.Scale = "1"
		}
		if t.Offset == "" {
			t.Offset = "0"
		}

		g.Printf("s = pad(strconv.FormatUint(uint64((%s.%s + %s) / %s), 2), 8 - len(str)%%8)\n", name, t.Name, t.Offset, t.Scale)
		g.Printf("if len(s) > (8 - len(str)%%8) {\n")
		g.Printf("err = errors.New(\"Value assigned for %s.%s exceeds limit\")\n", name, t.Name)
		g.Printf("return []byte{}, err\n")
		g.Printf("}\n")
		g.Printf("str += s\n\n")
		return
	}
	if t.Type == "uint32" {
		if t.Scale == "" {
			t.Scale = "1"
		}
		if t.Offset == "" {
			t.Offset = "0"
		}

		g.Printf("s = pad(strconv.FormatUint(uint64((%s.%s + %s) / %s), 2), %d)\n", name, t.Name, t.Offset, t.Scale, t.Size)
		g.Printf("if len(s) > %d {\n", t.Size)
		g.Printf("err = errors.New(\"Value assigned for %s.%s exceeds limit\")\n", name, t.Name)
		g.Printf("return []byte{}, err\n")
		g.Printf("}\n")
		g.Printf("str += s\n")
		if t.Repeated > 1 {
			g.Printf("}\n")
		}
		g.Printf("\n")
		return

	}
	if t.Type == "uint64" {
		if t.Scale == "" {
			t.Scale = "1"
		}
		if t.Offset == "" {
			t.Offset = "0"
		}

		g.Printf("s = pad(strconv.FormatUint(((%s.%s + %s) / %s), 2), %d)\n", name, t.Name, t.Offset, t.Scale, t.Size)
		g.Printf("if len(s) > %d {\n", t.Size)
		g.Printf("err = errors.New(\"Value assigned for %s.%s exceeds limit\")\n", name, t.Name)
		g.Printf("return []byte{}, err\n")
		g.Printf("}\n")
		g.Printf("str += s\n")
		if t.Repeated > 1 {
			g.Printf("}\n")
		}
		g.Printf("\n")
		return

	}
	if t.Type == "byte" {
		g.Printf("str += pad(strconv.FormatUint(uint64(%s.%s), 2), %d)\n", name, t.Name, t.Size)
		if t.Repeated > 1 {
			g.Printf("}\n")
		}
		return
	}
	if t.Type == "float32" {
		if t.Scale == "" {
			t.Scale = "1"
		}
		if t.Offset == "" {
			t.Offset = "0"
		}

		g.Printf("s = pad(strconv.FormatUint(uint64((%s.%s + %s) / %s), 2), %d)\n", name, t.Name, t.Offset, t.Scale, t.Size)
		g.Printf("if len(s) > %d {\n", t.Size)
		g.Printf("err = errors.New(\"Value assigned for %s.%s exceeds limit\")\n", name, t.Name)
		g.Printf("return []byte{}, err\n")
		g.Printf("}\n")
		g.Printf("str += s\n")
		if t.Repeated > 1 {
			g.Printf("}\n")
		}
		g.Printf("\n")
		return

	}
	if t.Type == "[]byte" {
		if t.Reference != "" {
			g.Printf("if %d < int(%s.%s) * 8 {\n", t.Size, name, t.Reference)
			g.Printf("err = errors.New(\"%s.%s is larger than limit\")\n", name, t.Reference)
			g.Printf("return []byte{}, err }\n")

			g.Printf("s, err = encodeFromByte(%s.%s, int(%s.%s) * 8)\n", name, t.Name, name, t.Reference)
			g.Printf("if err != nil {\n")
			g.Printf("return []byte{}, err\n")
			g.Printf("}\n")
			g.Printf("str += s\n")
		} else {
			g.Printf("s, err = encodeFromByte(%s.%s, %d)\n", name, t.Name, t.Size)
			g.Printf("if err != nil {\n")
			g.Printf("return []byte{}, err\n")
			g.Printf("}\n")
			g.Printf("str += s\n")
		}
		if t.Repeated > 1 {
			g.Printf("}\n")
		}
		g.Printf("\n")
		return
	}
	if t.Repeated > 1 {
		g.Printf("s, err = %s.%s[i].encode()\n", name, t.Name)
	} else {
		g.Printf("s, err = %s.%s.encode()\n", name, t.Name)
	}
	g.Printf("if err != nil {\n")
	g.Printf("return []byte{}, err\n")
	g.Printf("}\n")
	g.Printf("str += s\n")

	if t.Repeated > 1 {
		g.Printf("}\n")
	}
	g.Printf("\n")
	return
}

const padFunc = `
func pad(str string, length int) string {
    if (len(str) >= length) {
            return str
    }
    str = strings.Repeat("0", length - len(str)) + str
    return str
}
`

const decodeByteFunc = `
func decodeToByte(input string) ([]byte, error) {
        length := len(input)
        count := length / 8;
        byteList := make([]byte, 0)
        var err error
        if count == 0 { return byteList, err}
        for i := 0; i < count; i++ {
                num, err := strconv.ParseUint(input[8*i:8+8*i], 2, 32)
                if err != nil {
                        return byteList, err
                }
                if num == 0 { 
                        break
                }
                byteList = append(byteList, byte(num))
        }
        return byteList, err
}
`

const encodeByteFunc = `
func encodeFromByte(byteList []byte, size int) (string, error) {
        var str string = ""
        for _, b := range byteList {
                str += pad(strconv.FormatUint(uint64(b), 2), 8)
        }
        for i := 0; i < size - len(byteList) * 8; i = i + 8 {
                str += "00100000"
        }
        return str, nil
}
`

const decByteFunc = `
func decToByte(input string) ([]byte, error) {
        length := len(input)
        count := length / 8;
        byteList := make([]byte, count)
        var err error
        if count == 0 { return byteList, err}
        for i := 0; i < count; i++ {
                num, err := strconv.ParseUint(input[8*i:8+8*i], 2, 32)
                if err != nil {
                        return byteList, err
                }
                byteList[i] = byte(num)
        }
        return byteList, err
}
`

const encByteFunc = `
func encFromByte(byteList []byte) (string, error) {
        var str string = ""
        for _, b := range byteList {
                str += pad(strconv.FormatUint(uint64(b), 2), 8)
        }
        return str, nil
}
`

const omnicomInterface = `
type Omnicom interface {
    Parse(string)       error
    Encode()            ([]byte, error)
	getHeader()         byte
	getCRC()			uint32
	setCRC(uint32)
}
`

const parseFuncHead = `
func Parse(input []byte) (Omnicom, error) {
    var err error
    err = errors.New("No messages match")
    str, _ := encFromByte(input)
    //err = checkCRC(str)
    //if err != nil {
    //        return nil, err
    //}
    switch str[0:8] {
`

const parseFuncCase = `
    %s := new(%s)
    err := %s.Parse(str)
    if err != nil {
            return nil, err
    }
    %s.Header = input[0]
    return %s, err
`

const checkFunc = `
func checkCRC(input string) error {
        dividend := input
        index := 0
        divisor := "100110001"
        for index < len(dividend) - 8 {
                if dividend[index] == '1' {
                        dividend = divide(dividend, divisor, index)
                }
                index++
        }
        if dividend[len(dividend)-8:] != "00000000" {
                err := errors.New("CRC check failed for input string")
                return err
        }
        return nil
}
`

const attachFunc = `
func attachCRC(input string) string {
        dividend := input[:len(input)-8]
        result := dividend
        dividend = dividend + "00000000"
        index := 0
        divisor := "100110001"
        for index < len(dividend) - 8 {
                if dividend[index] == '1' {
                        dividend = divide(dividend, divisor, index)
                }
                index++
        }
        result = result + dividend[len(dividend)-8:]
        return result
}
`

const divideFunc = `
func divide(dividend string, divisor string, index int) string {
        var buffer bytes.Buffer
        for i:= index; i < index+9; i++ {
                if dividend[i] == divisor[i-index] {
                        buffer.WriteString("0")
                } else {
                        buffer.WriteString("1")
                }
        }
        return dividend[:index]+buffer.String()+dividend[index+9:]
}
`
