// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixASN prefix
	PrefixASN = "ASN"
)

// ASN represents fix data.
type CoreASN struct {
	Destination1ID uint32

	Destination1IDValidity bool

	ReportingRate1 uint32

	ReportingRate1Validity bool

	SlotAssignment1 uint32

	SlotAssignment1Validity bool

	SlotIncrement1 uint32

	SlotIncrement1Validity bool

	Destination2ID uint32

	Destination2IDValidity bool

	ReportingRate2 uint32

	ReportingRate2Validity bool

	SlotAssignment2 uint32

	SlotAssignment2Validity bool

	SlotIncrement2 uint32

	SlotIncrement2Validity bool

	BroadcastChannel uint32

	BroadcastChannelValidity bool

	Status string

	StatusValidity bool
}

type ASN struct {
	BaseSentence
	CoreASN
}

func NewASN(sentence BaseSentence) *ASN {
	s := new(ASN)
	s.BaseSentence = sentence

	s.Destination1IDValidity = false

	s.ReportingRate1Validity = false

	s.SlotAssignment1Validity = false

	s.SlotIncrement1Validity = false

	s.Destination2IDValidity = false

	s.ReportingRate2Validity = false

	s.SlotAssignment2Validity = false

	s.SlotIncrement2Validity = false

	s.BroadcastChannelValidity = false

	s.StatusValidity = false

	return s
}

func (s *ASN) parse() error {
	var err error

	if s.Format != PrefixASN {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixASN)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseUint(s.Fields[0], 10, 32)
			if err != nil {
				return fmt.Errorf("ASN decode variation error: %s", s.Fields[0])
			} else {
				s.CoreASN.Destination1ID = uint32(i)
				s.CoreASN.Destination1IDValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseUint(s.Fields[1], 10, 32)
			if err != nil {
				return fmt.Errorf("ASN decode variation error: %s", s.Fields[1])
			} else {
				s.CoreASN.ReportingRate1 = uint32(i)
				s.CoreASN.ReportingRate1Validity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseUint(s.Fields[2], 10, 32)
			if err != nil {
				return fmt.Errorf("ASN decode variation error: %s", s.Fields[2])
			} else {
				s.CoreASN.SlotAssignment1 = uint32(i)
				s.CoreASN.SlotAssignment1Validity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			i, err := strconv.ParseUint(s.Fields[3], 10, 32)
			if err != nil {
				return fmt.Errorf("ASN decode variation error: %s", s.Fields[3])
			} else {
				s.CoreASN.SlotIncrement1 = uint32(i)
				s.CoreASN.SlotIncrement1Validity = true
			}

		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseUint(s.Fields[4], 10, 32)
			if err != nil {
				return fmt.Errorf("ASN decode variation error: %s", s.Fields[4])
			} else {
				s.CoreASN.Destination2ID = uint32(i)
				s.CoreASN.Destination2IDValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			i, err := strconv.ParseUint(s.Fields[5], 10, 32)
			if err != nil {
				return fmt.Errorf("ASN decode variation error: %s", s.Fields[5])
			} else {
				s.CoreASN.ReportingRate2 = uint32(i)
				s.CoreASN.ReportingRate2Validity = true
			}

		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			i, err := strconv.ParseUint(s.Fields[6], 10, 32)
			if err != nil {
				return fmt.Errorf("ASN decode variation error: %s", s.Fields[6])
			} else {
				s.CoreASN.SlotAssignment2 = uint32(i)
				s.CoreASN.SlotAssignment2Validity = true
			}

		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			i, err := strconv.ParseUint(s.Fields[7], 10, 32)
			if err != nil {
				return fmt.Errorf("ASN decode variation error: %s", s.Fields[7])
			} else {
				s.CoreASN.SlotIncrement2 = uint32(i)
				s.CoreASN.SlotIncrement2Validity = true
			}

		}
	}

	if len(s.Fields) == 8 {
		return nil
	} else {
		if s.Fields[8] != "" {
			i, err := strconv.ParseUint(s.Fields[8], 10, 32)
			if err != nil {
				return fmt.Errorf("ASN decode variation error: %s", s.Fields[8])
			} else {
				s.CoreASN.BroadcastChannel = uint32(i)
				s.CoreASN.BroadcastChannelValidity = true
			}

		}
	}

	if len(s.Fields) == 9 {
		return nil
	} else {
		if s.Fields[9] != "" {
			s.Status = s.Fields[9]
			s.StatusValidity = true
		}
	}

	return nil
}

func (s *ASN) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixASN {
		err := fmt.Errorf("Sentence format %s is not a ASN sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.Destination1IDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.Destination1ID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.Destination1ID), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ReportingRate1Validity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.ReportingRate1), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.ReportingRate1), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SlotAssignment1Validity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.SlotAssignment1), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.SlotAssignment1), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SlotIncrement1Validity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.SlotIncrement1), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.SlotIncrement1), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.Destination2IDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.Destination2ID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.Destination2ID), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ReportingRate2Validity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.ReportingRate2), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.ReportingRate2), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SlotAssignment2Validity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.SlotAssignment2), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.SlotAssignment2), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SlotIncrement2Validity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.SlotIncrement2), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.SlotIncrement2), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.BroadcastChannelValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.BroadcastChannel), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreASN.BroadcastChannel), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StatusValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreASN.Status

		} else {
			Raw = Raw + "," + s.CoreASN.Status
		}
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
