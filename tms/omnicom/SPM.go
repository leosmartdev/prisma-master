//Split packet message(0x40), Iridium
// Code generated by omnicom; DO NOT EDIT
package omnicom

import (
	"errors"
	"strconv"
)

type SPM struct {
	Header                       byte
	Split_Msg_ID                 uint64
	Packet_Number                uint32
	Packets_Total_Count          uint32
	Length_Msg_Data_Part_in_Byte uint32
	Padding1                     uint32
	Msg_Data_Part                []byte
	CRC                          uint32
}

func (SPM *SPM) Parse(input string) error {
	var err error
	var count int = 0
	if count+8 > len(input) {
		err = errors.New("Input message length of SPM is shorter than required")
		return err
	}
	count = count + 8
	var num uint64
	if count+64 > len(input) {
		err = errors.New("Input message length of SPM is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+64], 2, 32)
	SPM.Split_Msg_ID = num*1 - 0
	count = count + 64
	if err != nil {
		return err
	}
	if count+8 > len(input) {
		err = errors.New("Input message length of SPM is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	SPM.Packet_Number = uint32(num*1 - 0)
	count = count + 8
	if err != nil {
		return err
	}
	if count+8 > len(input) {
		err = errors.New("Input message length of SPM is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	SPM.Packets_Total_Count = uint32(num*1 - 0)
	count = count + 8
	if err != nil {
		return err
	}
	if count+9 > len(input) {
		err = errors.New("Input message length of SPM is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+9], 2, 32)
	SPM.Length_Msg_Data_Part_in_Byte = uint32(num*1 - 0)
	count = count + 9
	if err != nil {
		return err
	}
	if count+7 > len(input) {
		err = errors.New("Input message length of SPM is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+7], 2, 32)
	SPM.Padding1 = uint32(num*1 - 0)
	count = count + 7
	if err != nil {
		return err
	}
	if count+int(SPM.Length_Msg_Data_Part_in_Byte)*8 > len(input) {
		err = errors.New("Input message length of SPM is shorter than required")
		return err
	}
	if 2608 < int(SPM.Length_Msg_Data_Part_in_Byte)*8 {
		err = errors.New("SPM.Length_Msg_Data_Part_in_Byte is larger than limit")
		return err
	}
	SPM.Msg_Data_Part, err = decodeToByte(input[count : count+int(SPM.Length_Msg_Data_Part_in_Byte)*8])
	count = count + int(SPM.Length_Msg_Data_Part_in_Byte)*8
	if err != nil {
		return err
	}
	if count+8 > len(input) {
		err = errors.New("Input message length of SPM is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	SPM.CRC = uint32(num*1 - 0)
	count = count + 8
	if err != nil {
		return err
	}
	return err
}
func (SPM *SPM) Encode() ([]byte, error) {
	var str string
	var s string
	var err error
	str += pad(strconv.FormatUint(uint64(SPM.Header), 2), 8)
	s = pad(strconv.FormatUint(((SPM.Split_Msg_ID+0)/1), 2), 64)
	if len(s) > 64 {
		err = errors.New("Value assigned for SPM.Split_Msg_ID exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((SPM.Packet_Number+0)/1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for SPM.Packet_Number exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((SPM.Packets_Total_Count+0)/1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for SPM.Packets_Total_Count exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((SPM.Length_Msg_Data_Part_in_Byte+0)/1), 2), 9)
	if len(s) > 9 {
		err = errors.New("Value assigned for SPM.Length_Msg_Data_Part_in_Byte exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((SPM.Padding1+0)/1), 2), 7)
	if len(s) > 7 {
		err = errors.New("Value assigned for SPM.Padding1 exceeds limit")
		return []byte{}, err
	}
	str += s

	if 2608 < int(SPM.Length_Msg_Data_Part_in_Byte)*8 {
		err = errors.New("SPM.Length_Msg_Data_Part_in_Byte is larger than limit")
		return []byte{}, err
	}
	s, err = encodeFromByte(SPM.Msg_Data_Part, int(SPM.Length_Msg_Data_Part_in_Byte)*8)
	if err != nil {
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((SPM.CRC+0)/1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for SPM.CRC exceeds limit")
		return []byte{}, err
	}
	str += s

	str = attachCRC(str)
	byteList, err := decToByte(str)
	return byteList, err
}
func (SPM *SPM) getHeader() byte {
	return SPM.Header
}
func (SPM *SPM) getCRC() uint32 {
	return SPM.CRC
}
func (SPM *SPM) setCRC(crc uint32) {
	SPM.CRC = crc
}
