// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixGLL prefix
	PrefixGLL = "GLL"
)

// GLL represents fix data.
type CoreGLL struct {
	Latitude float64

	LatitudeValidity bool

	LatitudeFirection string

	LatitudeFirectionValidity bool

	Longitude float64

	LongitudeValidity bool

	LongitudeDirection string

	LongitudeDirectionValidity bool

	UtcTime float64

	UtcTimeValidity bool

	Status string

	StatusValidity bool

	ModeIndicator string

	ModeIndicatorValidity bool
}

type GLL struct {
	BaseSentence
	CoreGLL
}

func NewGLL(sentence BaseSentence) *GLL {
	s := new(GLL)
	s.BaseSentence = sentence

	s.LatitudeValidity = false

	s.LatitudeFirectionValidity = false

	s.LongitudeValidity = false

	s.LongitudeDirectionValidity = false

	s.UtcTimeValidity = false

	s.StatusValidity = false

	s.ModeIndicatorValidity = false

	return s
}

func (s *GLL) parse() error {
	var err error

	if s.Format != PrefixGLL {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixGLL)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseFloat(s.Fields[0], 64)
			if err != nil {
				return fmt.Errorf("GLL decode variation error: %s", s.Fields[0])
			} else {
				s.CoreGLL.Latitude = float64(i)
				s.CoreGLL.LatitudeValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			s.LatitudeFirection = s.Fields[1]
			s.LatitudeFirectionValidity = true
		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseFloat(s.Fields[2], 64)
			if err != nil {
				return fmt.Errorf("GLL decode variation error: %s", s.Fields[2])
			} else {
				s.CoreGLL.Longitude = float64(i)
				s.CoreGLL.LongitudeValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			s.LongitudeDirection = s.Fields[3]
			s.LongitudeDirectionValidity = true
		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseFloat(s.Fields[4], 64)
			if err != nil {
				return fmt.Errorf("GLL decode variation error: %s", s.Fields[4])
			} else {
				s.CoreGLL.UtcTime = float64(i)
				s.CoreGLL.UtcTimeValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			s.Status = s.Fields[5]
			s.StatusValidity = true
		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			s.ModeIndicator = s.Fields[6]
			s.ModeIndicatorValidity = true
		}
	}

	return nil
}

func (s *GLL) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixGLL {
		err := fmt.Errorf("Sentence format %s is not a GLL sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.LatitudeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreGLL.Latitude, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreGLL.Latitude, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LatitudeFirectionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreGLL.LatitudeFirection

		} else {
			Raw = Raw + "," + s.CoreGLL.LatitudeFirection
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LongitudeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreGLL.Longitude, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreGLL.Longitude, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LongitudeDirectionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreGLL.LongitudeDirection

		} else {
			Raw = Raw + "," + s.CoreGLL.LongitudeDirection
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.UtcTimeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreGLL.UtcTime, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreGLL.UtcTime, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StatusValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreGLL.Status

		} else {
			Raw = Raw + "," + s.CoreGLL.Status
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ModeIndicatorValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreGLL.ModeIndicator

		} else {
			Raw = Raw + "," + s.CoreGLL.ModeIndicator
		}
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
