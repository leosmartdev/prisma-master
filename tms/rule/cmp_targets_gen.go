// prisma/tms/generator/rule/cmp_targets.go
// GENERATED BY THE FILE ABOVE; DO NOT EDIT

package rule

import ("errors"
google_protobuf1 "github.com/golang/protobuf/ptypes/wrappers"
)

func compGreaterEqualValue(val, valOrigin interface{}) (bool, error) {
	switch defVal := val.(type) {
	// if specificValue is zero then we don't measure with our target
	case int32:
		if resVal, ok := valOrigin.(int32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal >= defVal, nil
		}
	case int64:
		if resVal, ok := valOrigin.(int64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal >= defVal, nil
		}
	case uint32:
		if resVal, ok := valOrigin.(uint32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal >= defVal, nil
		}
	case uint64:
		if resVal, ok := valOrigin.(uint64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal >= defVal, nil
		}
	case float32:
		if resVal, ok := valOrigin.(float32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal >= defVal, nil
		}
	case float64:
		if resVal, ok := valOrigin.(float64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal >= defVal, nil
		}
	case string:
		if resVal, ok := valOrigin.(string); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal >= defVal, nil
		}
	case *google_protobuf1.DoubleValue:
		if resVal, ok := valOrigin.(*google_protobuf1.DoubleValue); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			if resVal == nil || defVal == nil {
				return false, nil
			}
			return resVal.Value >= defVal.Value, nil
		}
	default:
		return false, errors.New("unknown type")
	}
}

func compLesserValue(val, valOrigin interface{}) (bool, error) {
	switch defVal := val.(type) {
	// if specificValue is zero then we don't measure with our target
	case int32:
		if resVal, ok := valOrigin.(int32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal < defVal, nil
		}
	case int64:
		if resVal, ok := valOrigin.(int64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal < defVal, nil
		}
	case uint32:
		if resVal, ok := valOrigin.(uint32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal < defVal, nil
		}
	case uint64:
		if resVal, ok := valOrigin.(uint64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal < defVal, nil
		}
	case float32:
		if resVal, ok := valOrigin.(float32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal < defVal, nil
		}
	case float64:
		if resVal, ok := valOrigin.(float64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal < defVal, nil
		}
	case string:
		if resVal, ok := valOrigin.(string); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal < defVal, nil
		}
	case *google_protobuf1.DoubleValue:
		if resVal, ok := valOrigin.(*google_protobuf1.DoubleValue); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			if resVal == nil || defVal == nil {
				return false, nil
			}
			return resVal.Value < defVal.Value, nil
		}
	default:
		return false, errors.New("unknown type")
	}
}

func compLesserEqualValue(val, valOrigin interface{}) (bool, error) {
	switch defVal := val.(type) {
	// if specificValue is zero then we don't measure with our target
	case int32:
		if resVal, ok := valOrigin.(int32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal <= defVal, nil
		}
	case int64:
		if resVal, ok := valOrigin.(int64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal <= defVal, nil
		}
	case uint32:
		if resVal, ok := valOrigin.(uint32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal <= defVal, nil
		}
	case uint64:
		if resVal, ok := valOrigin.(uint64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal <= defVal, nil
		}
	case float32:
		if resVal, ok := valOrigin.(float32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal <= defVal, nil
		}
	case float64:
		if resVal, ok := valOrigin.(float64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal <= defVal, nil
		}
	case string:
		if resVal, ok := valOrigin.(string); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal <= defVal, nil
		}
	case *google_protobuf1.DoubleValue:
		if resVal, ok := valOrigin.(*google_protobuf1.DoubleValue); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			if resVal == nil || defVal == nil {
				return false, nil
			}
			return resVal.Value <= defVal.Value, nil
		}
	default:
		return false, errors.New("unknown type")
	}
}

func compEqualValue(val, valOrigin interface{}) (bool, error) {
	switch defVal := val.(type) {
	// if specificValue is zero then we don't measure with our target
	case int32:
		if resVal, ok := valOrigin.(int32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal == defVal, nil
		}
	case int64:
		if resVal, ok := valOrigin.(int64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal == defVal, nil
		}
	case uint32:
		if resVal, ok := valOrigin.(uint32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal == defVal, nil
		}
	case uint64:
		if resVal, ok := valOrigin.(uint64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal == defVal, nil
		}
	case float32:
		if resVal, ok := valOrigin.(float32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal == defVal, nil
		}
	case float64:
		if resVal, ok := valOrigin.(float64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal == defVal, nil
		}
	case string:
		if resVal, ok := valOrigin.(string); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal == defVal, nil
		}
	case *google_protobuf1.DoubleValue:
		if resVal, ok := valOrigin.(*google_protobuf1.DoubleValue); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			if resVal == nil || defVal == nil {
				return false, nil
			}
			return resVal.Value == defVal.Value, nil
		}
	default:
		return false, errors.New("unknown type")
	}
}

func compGreaterValue(val, valOrigin interface{}) (bool, error) {
	switch defVal := val.(type) {
	// if specificValue is zero then we don't measure with our target
	case int32:
		if resVal, ok := valOrigin.(int32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal > defVal, nil
		}
	case int64:
		if resVal, ok := valOrigin.(int64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal > defVal, nil
		}
	case uint32:
		if resVal, ok := valOrigin.(uint32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal > defVal, nil
		}
	case uint64:
		if resVal, ok := valOrigin.(uint64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal > defVal, nil
		}
	case float32:
		if resVal, ok := valOrigin.(float32); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal > defVal, nil
		}
	case float64:
		if resVal, ok := valOrigin.(float64); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal > defVal, nil
		}
	case string:
		if resVal, ok := valOrigin.(string); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			return resVal > defVal, nil
		}
	case *google_protobuf1.DoubleValue:
		if resVal, ok := valOrigin.(*google_protobuf1.DoubleValue); !ok {
			return false, errors.New("Bad type for valOrigin")
		} else {
			if resVal == nil || defVal == nil {
				return false, nil
			}
			return resVal.Value > defVal.Value, nil
		}
	default:
		return false, errors.New("unknown type")
	}
}
