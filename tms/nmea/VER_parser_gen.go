// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixVER prefix
	PrefixVER = "VER"
)

// VER represents fix data.
type CoreVER struct {
	SentenceCount uint32

	SentenceCountValidity bool

	SentenceIndex uint32

	SentenceIndexValidity bool

	DeviceType string

	DeviceTypeValidity bool

	VendorId string

	VendorIdValidity bool

	DeviceID string

	DeviceIDValidity bool

	SerialNumber string

	SerialNumberValidity bool

	ModelNumber string

	ModelNumberValidity bool

	SoftwareVersion string

	SoftwareVersionValidity bool

	HardwareVersion string

	HardwareVersionValidity bool

	SeqMsgID uint32

	SeqMsgIDValidity bool
}

type VER struct {
	BaseSentence
	CoreVER
}

func NewVER(sentence BaseSentence) *VER {
	s := new(VER)
	s.BaseSentence = sentence

	s.SentenceCountValidity = false

	s.SentenceIndexValidity = false

	s.DeviceTypeValidity = false

	s.VendorIdValidity = false

	s.DeviceIDValidity = false

	s.SerialNumberValidity = false

	s.ModelNumberValidity = false

	s.SoftwareVersionValidity = false

	s.HardwareVersionValidity = false

	s.SeqMsgIDValidity = false

	return s
}

func (s *VER) parse() error {
	var err error

	if s.Format != PrefixVER {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixVER)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseUint(s.Fields[0], 10, 32)
			if err != nil {
				return fmt.Errorf("VER decode variation error: %s", s.Fields[0])
			} else {
				s.CoreVER.SentenceCount = uint32(i)
				s.CoreVER.SentenceCountValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseUint(s.Fields[1], 10, 32)
			if err != nil {
				return fmt.Errorf("VER decode variation error: %s", s.Fields[1])
			} else {
				s.CoreVER.SentenceIndex = uint32(i)
				s.CoreVER.SentenceIndexValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			s.DeviceType = s.Fields[2]
			s.DeviceTypeValidity = true
		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			s.VendorId = s.Fields[3]
			s.VendorIdValidity = true
		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			s.DeviceID = s.Fields[4]
			s.DeviceIDValidity = true
		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			s.SerialNumber = s.Fields[5]
			s.SerialNumberValidity = true
		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			s.ModelNumber = s.Fields[6]
			s.ModelNumberValidity = true
		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			s.SoftwareVersion = s.Fields[7]
			s.SoftwareVersionValidity = true
		}
	}

	if len(s.Fields) == 8 {
		return nil
	} else {
		if s.Fields[8] != "" {
			s.HardwareVersion = s.Fields[8]
			s.HardwareVersionValidity = true
		}
	}

	if len(s.Fields) == 9 {
		return nil
	} else {
		if s.Fields[9] != "" {
			i, err := strconv.ParseUint(s.Fields[9], 10, 32)
			if err != nil {
				return fmt.Errorf("VER decode variation error: %s", s.Fields[9])
			} else {
				s.CoreVER.SeqMsgID = uint32(i)
				s.CoreVER.SeqMsgIDValidity = true
			}

		}
	}

	return nil
}

func (s *VER) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixVER {
		err := fmt.Errorf("Sentence format %s is not a VER sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.SentenceCountValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreVER.SentenceCount), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreVER.SentenceCount), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SentenceIndexValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreVER.SentenceIndex), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreVER.SentenceIndex), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.DeviceTypeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreVER.DeviceType

		} else {
			Raw = Raw + "," + s.CoreVER.DeviceType
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.VendorIdValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreVER.VendorId

		} else {
			Raw = Raw + "," + s.CoreVER.VendorId
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.DeviceIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreVER.DeviceID

		} else {
			Raw = Raw + "," + s.CoreVER.DeviceID
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SerialNumberValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreVER.SerialNumber

		} else {
			Raw = Raw + "," + s.CoreVER.SerialNumber
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ModelNumberValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreVER.ModelNumber

		} else {
			Raw = Raw + "," + s.CoreVER.ModelNumber
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SoftwareVersionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreVER.SoftwareVersion

		} else {
			Raw = Raw + "," + s.CoreVER.SoftwareVersion
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.HardwareVersionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreVER.HardwareVersion

		} else {
			Raw = Raw + "," + s.CoreVER.HardwareVersion
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SeqMsgIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreVER.SeqMsgID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreVER.SeqMsgID), 10)
		}

	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
