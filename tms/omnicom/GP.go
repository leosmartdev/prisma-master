//Global parameters(0x03), Iridium/3G
// Code generated by omnicom; DO NOT EDIT
package omnicom

import (
	"errors"
	"strconv"
)

type GP struct {
	Header                       byte
	Beacon_ID                    uint32
	ID_Msg                       uint32
	Date_Position                Date_Position
	Position_Reporting_Interval  Position_Reporting_Interval
	Geofencing_Enable            Geofencing_Enable
	Position_Collection_Interval Position_Collection_Interval
	Password                     Password
	Routing                      Routing
	Firmware_Dome_Version        []byte
	Junction_Box_Version         []byte
	SIM_Card_ICCID               []byte
	G3_IMEI                      []byte
	IRI_IMEI                     []byte
	CRC                          uint32
}

func (GP *GP) Parse(input string) error {
	var err error
	if len(input) > 712 {
		err = errors.New("Input message is longer than limit")
		return err
	}
	var count int = 0
	if count+8 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	count = count + 8
	var num uint64
	if count+20 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+20], 2, 32)
	GP.Beacon_ID = uint32(num*1 - 0)
	count = count + 20
	if err != nil {
		return err
	}
	if count+12 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+12], 2, 32)
	GP.ID_Msg = uint32(num*1 - 0)
	count = count + 12
	if err != nil {
		return err
	}
	if count+70 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	GP.Date_Position = *new(Date_Position)
	err = GP.Date_Position.parse(input[count : count+70])
	count = count + 70
	if err != nil {
		return err
	}
	if count+10 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	GP.Position_Reporting_Interval = *new(Position_Reporting_Interval)
	err = GP.Position_Reporting_Interval.parse(input[count : count+10])
	count = count + 10
	if err != nil {
		return err
	}
	if count+2 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	GP.Geofencing_Enable = *new(Geofencing_Enable)
	err = GP.Geofencing_Enable.parse(input[count : count+2])
	count = count + 2
	if err != nil {
		return err
	}
	if count+10 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	GP.Position_Collection_Interval = *new(Position_Collection_Interval)
	err = GP.Position_Collection_Interval.parse(input[count : count+10])
	count = count + 10
	if err != nil {
		return err
	}
	if count+121 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	GP.Password = *new(Password)
	err = GP.Password.parse(input[count : count+121])
	count = count + 121
	if err != nil {
		return err
	}
	if count+3 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	GP.Routing = *new(Routing)
	err = GP.Routing.parse(input[count : count+3])
	count = count + 3
	if err != nil {
		return err
	}
	if count+24 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	GP.Firmware_Dome_Version, err = decodeToByte(input[count : count+24])
	count = count + 24
	if err != nil {
		return err
	}
	if count+24 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	GP.Junction_Box_Version, err = decodeToByte(input[count : count+24])
	count = count + 24
	if err != nil {
		return err
	}
	if count+160 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	GP.SIM_Card_ICCID, err = decodeToByte(input[count : count+160])
	count = count + 160
	if err != nil {
		return err
	}
	if count+120 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	GP.G3_IMEI, err = decodeToByte(input[count : count+120])
	count = count + 120
	if err != nil {
		return err
	}
	if count+120 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	GP.IRI_IMEI, err = decodeToByte(input[count : count+120])
	count = count + 120
	if err != nil {
		return err
	}
	if count+8 > len(input) {
		err = errors.New("Input message length of GP is shorter than required")
		return err
	}
	num, err = strconv.ParseUint(input[count:count+8], 2, 32)
	GP.CRC = uint32(num*1 - 0)
	count = count + 8
	if err != nil {
		return err
	}
	return err
}
func (GP *GP) Encode() ([]byte, error) {
	var str string
	var s string
	var err error
	str += pad(strconv.FormatUint(uint64(GP.Header), 2), 8)
	s = pad(strconv.FormatUint(uint64((GP.Beacon_ID+0)/1), 2), 20)
	if len(s) > 20 {
		err = errors.New("Value assigned for GP.Beacon_ID exceeds limit")
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((GP.ID_Msg+0)/1), 2), 12)
	if len(s) > 12 {
		err = errors.New("Value assigned for GP.ID_Msg exceeds limit")
		return []byte{}, err
	}
	str += s

	s, err = GP.Date_Position.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = GP.Position_Reporting_Interval.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = GP.Geofencing_Enable.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = GP.Position_Collection_Interval.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = GP.Password.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = GP.Routing.encode()
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = encodeFromByte(GP.Firmware_Dome_Version, 24)
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = encodeFromByte(GP.Junction_Box_Version, 24)
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = encodeFromByte(GP.SIM_Card_ICCID, 160)
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = encodeFromByte(GP.G3_IMEI, 120)
	if err != nil {
		return []byte{}, err
	}
	str += s

	s, err = encodeFromByte(GP.IRI_IMEI, 120)
	if err != nil {
		return []byte{}, err
	}
	str += s

	s = pad(strconv.FormatUint(uint64((GP.CRC+0)/1), 2), 8)
	if len(s) > 8 {
		err = errors.New("Value assigned for GP.CRC exceeds limit")
		return []byte{}, err
	}
	str += s

	str = attachCRC(str)
	byteList, err := decToByte(str)
	return byteList, err
}
func (GP *GP) getHeader() byte {
	return GP.Header
}
func (GP *GP) getCRC() uint32 {
	return GP.CRC
}
func (GP *GP) setCRC(crc uint32) {
	GP.CRC = crc
}
