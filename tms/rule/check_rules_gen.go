// prisma/tms/generator/rule/check_rules.go
// GENERATED BY THE FILE ABOVE; DO NOT EDIT

package rule

import (
	"prisma/tms"
	"prisma/tms/log"
	"prisma/tms/moc"
)

// check a rule for a target. Return bool - is this check ok
func checkRuleForTargetAny(cond Rule_IfAny, track tms.Track) bool {
	var target *tms.Target
	if len(track.Targets) > 0 {
		target = track.Targets[0]
	} else {
		return false
	}
	switch cond.Operation {
	case Rule_EQUAL:
		return checkTargetByOperationAny(cond, *target, compEqualValue)
	case Rule_LESSER:
		return checkTargetByOperationAny(cond, *target, compLesserValue)
	case Rule_LESSER_EQUAL:
		return checkTargetByOperationAny(cond, *target, compLesserEqualValue)
	case Rule_GREATER:
		return checkTargetByOperationAny(cond, *target, compGreaterValue)
	case Rule_GREATER_EQUAL:
		return checkTargetByOperationAny(cond, *target, compGreaterEqualValue)
	case Rule_REGEX:
		return checkTargetByOperationAny(cond, *target, compRegExValue)
	}
	return false
}

// check a rule for a target. Return bool - is this check ok
func checkRuleForTargetAll(cond Rule_IfAll, track tms.Track) bool {
	var target *tms.Target
	if len(track.Targets) > 0 {
		target = track.Targets[0]
	} else {
		return false
	}
	switch cond.Operation {
	case Rule_EQUAL:
		return checkTargetByOperationAll(cond, *target, compEqualValue)
	case Rule_LESSER:
		return checkTargetByOperationAll(cond, *target, compLesserValue)
	case Rule_LESSER_EQUAL:
		return checkTargetByOperationAll(cond, *target, compLesserEqualValue)
	case Rule_GREATER:
		return checkTargetByOperationAll(cond, *target, compGreaterValue)
	case Rule_GREATER_EQUAL:
		return checkTargetByOperationAll(cond, *target, compGreaterEqualValue)
	case Rule_REGEX:
		return checkTargetByOperationAll(cond, *target, compRegExValue)
	}
	return false
}

// check a rule for a track. Return bool - is this check ok
func checkRuleForZoneAny(cond Rule_IfAny, track tms.Track,
	zones ZoneStore, insideZone map[string]map[string]bool) bool {
	var (
		target     *tms.Target
		zoneByName *moc.Zone
		err        error
	)
	if len(track.Targets) > 0 && cond.GetZone() != nil {
		target = track.Targets[0]
	} else {
		return false
	}
	if zoneByName, err = zones.GetByName(cond.GetZone().Name); err != nil {
		return false
	}

	if insideZone[cond.GetZone().Name] == nil {
		insideZone[cond.GetZone().Name] = make(map[string]bool)
	}
	isInside := zoneByName.Poly.ToGeo().Nearby(target.Point().Coordinates, 0)
	if isInside {
		insideZone[cond.GetZone().Name][track.LookupID()] = true
	}
	_, wasInside := insideZone[cond.GetZone().Name][track.LookupID()]

	switch cond.Operation {
	case Rule_IN:
		if isInside {
			insideZone[cond.GetZone().Name][track.LookupID()] = true
			return true
		}
	case Rule_OUT:
		if !isInside && wasInside {
			delete(insideZone[cond.GetZone().Name], track.LookupID())
			return true
		}
	}
	return false
}

// check a rule for a track. Return bool - is this check ok
func checkRuleForZoneAll(cond Rule_IfAll, track tms.Track,
	zones ZoneStore, insideZone map[string]map[string]bool) bool {
	var (
		target     *tms.Target
		zoneByName *moc.Zone
		err        error
	)
	if len(track.Targets) > 0 && cond.GetZone() != nil {
		target = track.Targets[0]
	} else {
		return false
	}
	if zoneByName, err = zones.GetByName(cond.GetZone().Name); err != nil {
		return false
	}

	if insideZone[cond.GetZone().Name] == nil {
		insideZone[cond.GetZone().Name] = make(map[string]bool)
	}
	isInside := zoneByName.Poly.ToGeo().Nearby(target.Point().Coordinates, 0)
	if isInside {
		insideZone[cond.GetZone().Name][track.LookupID()] = true
	}
	_, wasInside := insideZone[cond.GetZone().Name][track.LookupID()]

	switch cond.Operation {
	case Rule_IN:
		if isInside {
			insideZone[cond.GetZone().Name][track.LookupID()] = true
			return true
		}
	case Rule_OUT:
		if !isInside && wasInside {
			delete(insideZone[cond.GetZone().Name], track.LookupID())
			return true
		}
	}
	return false
}

// check a rule for a track. Return bool - is this check ok
func checkRuleForTrackAny(cond Rule_IfAny, track tms.Track) bool {
	switch cond.Operation {
	case Rule_TOWARD:
		trackCond := cond.GetTrack()
		return trackCond != nil && trackCond.RegistryId == track.RegistryId
	}
	return false
}

// check a rule for a track. Return bool - is this check ok
func checkRuleForTrackAll(cond Rule_IfAll, track tms.Track) bool {
	switch cond.Operation {
	case Rule_TOWARD:
		trackCond := cond.GetTrack()
		return trackCond != nil && trackCond.RegistryId == track.RegistryId
	}
	return false
}

// Check each fields which is pointed in condAll.CheckFields
func checkTargetByOperationAny(cond Rule_IfAny, original tms.Target, cmp fncCmp) bool {
	// Golang's authors advice don't use reflect, so we will use reflect
	goal := cond.GetTarget()
	if goal == nil {
		return false
	}
	for _, field := range cond.CheckFields {
		val, valOriginal, err := getValueBySpecificField(goal, original, field)
		if err != nil {
			return false
		}
		if retBool, err := cmp(val, valOriginal); !retBool || err != nil {
			if err != nil {
				log.Error("%!v(MISSING)", err)
			}
			return false
		}
	}
	return true
}

// Check each fields which is pointed in condAll.CheckFields
func checkTargetByOperationAll(cond Rule_IfAll, original tms.Target, cmp fncCmp) bool {
	// Golang's authors advice don't use reflect, so we will use reflect
	goal := cond.GetTarget()
	if goal == nil {
		return false
	}
	for _, field := range cond.CheckFields {
		val, valOriginal, err := getValueBySpecificField(goal, original, field)
		if err != nil {
			return false
		}
		if retBool, err := cmp(val, valOriginal); !retBool || err != nil {
			if err != nil {
				log.Error("%!v(MISSING)", err)
			}
			return false
		}
	}
	return true
}
