// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixBBM prefix
	PrefixBBM = "BBM"
)

// BBM represents fix data.
type CoreBBM struct {
	SentenceCount uint32

	SentenceCountValidity bool

	SentenceIndex uint32

	SentenceIndexValidity bool

	SeqMsgID uint32

	SeqMsgIDValidity bool

	Channel uint32

	ChannelValidity bool

	MessageID uint32

	MessageIDValidity bool

	Text string

	TextValidity bool

	FillBits uint32

	FillBitsValidity bool
}

type BBM struct {
	BaseSentence
	CoreBBM
}

func NewBBM(sentence BaseSentence) *BBM {
	s := new(BBM)
	s.BaseSentence = sentence

	s.SentenceCountValidity = false

	s.SentenceIndexValidity = false

	s.SeqMsgIDValidity = false

	s.ChannelValidity = false

	s.MessageIDValidity = false

	s.TextValidity = false

	s.FillBitsValidity = false

	return s
}

func (s *BBM) parse() error {
	var err error

	if s.Format != PrefixBBM {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixBBM)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseUint(s.Fields[0], 10, 32)
			if err != nil {
				return fmt.Errorf("BBM decode variation error: %s", s.Fields[0])
			} else {
				s.CoreBBM.SentenceCount = uint32(i)
				s.CoreBBM.SentenceCountValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			i, err := strconv.ParseUint(s.Fields[1], 10, 32)
			if err != nil {
				return fmt.Errorf("BBM decode variation error: %s", s.Fields[1])
			} else {
				s.CoreBBM.SentenceIndex = uint32(i)
				s.CoreBBM.SentenceIndexValidity = true
			}

		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseUint(s.Fields[2], 10, 32)
			if err != nil {
				return fmt.Errorf("BBM decode variation error: %s", s.Fields[2])
			} else {
				s.CoreBBM.SeqMsgID = uint32(i)
				s.CoreBBM.SeqMsgIDValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			i, err := strconv.ParseUint(s.Fields[3], 10, 32)
			if err != nil {
				return fmt.Errorf("BBM decode variation error: %s", s.Fields[3])
			} else {
				s.CoreBBM.Channel = uint32(i)
				s.CoreBBM.ChannelValidity = true
			}

		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseUint(s.Fields[4], 10, 32)
			if err != nil {
				return fmt.Errorf("BBM decode variation error: %s", s.Fields[4])
			} else {
				s.CoreBBM.MessageID = uint32(i)
				s.CoreBBM.MessageIDValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			s.Text = s.Fields[5]
			s.TextValidity = true
		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			i, err := strconv.ParseUint(s.Fields[6], 10, 32)
			if err != nil {
				return fmt.Errorf("BBM decode variation error: %s", s.Fields[6])
			} else {
				s.CoreBBM.FillBits = uint32(i)
				s.CoreBBM.FillBitsValidity = true
			}

		}
	}

	return nil
}

func (s *BBM) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixBBM {
		err := fmt.Errorf("Sentence format %s is not a BBM sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.SentenceCountValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.SentenceCount), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.SentenceCount), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SentenceIndexValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.SentenceIndex), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.SentenceIndex), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SeqMsgIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.SeqMsgID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.SeqMsgID), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ChannelValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.Channel), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.Channel), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.MessageIDValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.MessageID), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.MessageID), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.TextValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreBBM.Text

		} else {
			Raw = Raw + "," + s.CoreBBM.Text
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.FillBitsValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.FillBits), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreBBM.FillBits), 10)
		}

	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
