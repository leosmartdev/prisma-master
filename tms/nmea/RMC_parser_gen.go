// Code generated by parse_nmea; DO NOT EDIT
package nmea

import "fmt"
import "strings"
import "strconv"

const (
	// PrefixRMC prefix
	PrefixRMC = "RMC"
)

// RMC represents fix data.
type CoreRMC struct {
	UtcTime float64

	UtcTimeValidity bool

	Status string

	StatusValidity bool

	Latitude float64

	LatitudeValidity bool

	LatitudeDirection string

	LatitudeDirectionValidity bool

	Longitude float64

	LongitudeValidity bool

	LongitudeDirection string

	LongitudeDirectionValidity bool

	SpeedOverGround float64

	SpeedOverGroundValidity bool

	CourseOverGround float64

	CourseOverGroundValidity bool

	UtcDate uint32

	UtcDateValidity bool

	MagneticVariation float64

	MagneticVariationValidity bool

	MagneticVariationDirection string

	MagneticVariationDirectionValidity bool

	ModeIndicator string

	ModeIndicatorValidity bool
}

type RMC struct {
	BaseSentence
	CoreRMC
}

func NewRMC(sentence BaseSentence) *RMC {
	s := new(RMC)
	s.BaseSentence = sentence

	s.UtcTimeValidity = false

	s.StatusValidity = false

	s.LatitudeValidity = false

	s.LatitudeDirectionValidity = false

	s.LongitudeValidity = false

	s.LongitudeDirectionValidity = false

	s.SpeedOverGroundValidity = false

	s.CourseOverGroundValidity = false

	s.UtcDateValidity = false

	s.MagneticVariationValidity = false

	s.MagneticVariationDirectionValidity = false

	s.ModeIndicatorValidity = false

	return s
}

func (s *RMC) parse() error {
	var err error

	if s.Format != PrefixRMC {
		err = fmt.Errorf("%s is not a %s", s.Format, PrefixRMC)
		return err
	}

	if len(s.Fields) == 0 {
		return nil
	} else {
		if s.Fields[0] != "" {
			i, err := strconv.ParseFloat(s.Fields[0], 64)
			if err != nil {
				return fmt.Errorf("RMC decode variation error: %s", s.Fields[0])
			} else {
				s.CoreRMC.UtcTime = float64(i)
				s.CoreRMC.UtcTimeValidity = true
			}

		}
	}

	if len(s.Fields) == 1 {
		return nil
	} else {
		if s.Fields[1] != "" {
			s.Status = s.Fields[1]
			s.StatusValidity = true
		}
	}

	if len(s.Fields) == 2 {
		return nil
	} else {
		if s.Fields[2] != "" {
			i, err := strconv.ParseFloat(s.Fields[2], 64)
			if err != nil {
				return fmt.Errorf("RMC decode variation error: %s", s.Fields[2])
			} else {
				s.CoreRMC.Latitude = float64(i)
				s.CoreRMC.LatitudeValidity = true
			}

		}
	}

	if len(s.Fields) == 3 {
		return nil
	} else {
		if s.Fields[3] != "" {
			s.LatitudeDirection = s.Fields[3]
			s.LatitudeDirectionValidity = true
		}
	}

	if len(s.Fields) == 4 {
		return nil
	} else {
		if s.Fields[4] != "" {
			i, err := strconv.ParseFloat(s.Fields[4], 64)
			if err != nil {
				return fmt.Errorf("RMC decode variation error: %s", s.Fields[4])
			} else {
				s.CoreRMC.Longitude = float64(i)
				s.CoreRMC.LongitudeValidity = true
			}

		}
	}

	if len(s.Fields) == 5 {
		return nil
	} else {
		if s.Fields[5] != "" {
			s.LongitudeDirection = s.Fields[5]
			s.LongitudeDirectionValidity = true
		}
	}

	if len(s.Fields) == 6 {
		return nil
	} else {
		if s.Fields[6] != "" {
			i, err := strconv.ParseFloat(s.Fields[6], 64)
			if err != nil {
				return fmt.Errorf("RMC decode variation error: %s", s.Fields[6])
			} else {
				s.CoreRMC.SpeedOverGround = float64(i)
				s.CoreRMC.SpeedOverGroundValidity = true
			}

		}
	}

	if len(s.Fields) == 7 {
		return nil
	} else {
		if s.Fields[7] != "" {
			i, err := strconv.ParseFloat(s.Fields[7], 64)
			if err != nil {
				return fmt.Errorf("RMC decode variation error: %s", s.Fields[7])
			} else {
				s.CoreRMC.CourseOverGround = float64(i)
				s.CoreRMC.CourseOverGroundValidity = true
			}

		}
	}

	if len(s.Fields) == 8 {
		return nil
	} else {
		if s.Fields[8] != "" {
			i, err := strconv.ParseUint(s.Fields[8], 10, 32)
			if err != nil {
				return fmt.Errorf("RMC decode variation error: %s", s.Fields[8])
			} else {
				s.CoreRMC.UtcDate = uint32(i)
				s.CoreRMC.UtcDateValidity = true
			}

		}
	}

	if len(s.Fields) == 9 {
		return nil
	} else {
		if s.Fields[9] != "" {
			i, err := strconv.ParseFloat(s.Fields[9], 64)
			if err != nil {
				return fmt.Errorf("RMC decode variation error: %s", s.Fields[9])
			} else {
				s.CoreRMC.MagneticVariation = float64(i)
				s.CoreRMC.MagneticVariationValidity = true
			}

		}
	}

	if len(s.Fields) == 10 {
		return nil
	} else {
		if s.Fields[10] != "" {
			s.MagneticVariationDirection = s.Fields[10]
			s.MagneticVariationDirectionValidity = true
		}
	}

	if len(s.Fields) == 11 {
		return nil
	} else {
		if s.Fields[11] != "" {
			s.ModeIndicator = s.Fields[11]
			s.ModeIndicatorValidity = true
		}
	}

	return nil
}

func (s *RMC) Encode() (string, error) {
	var Raw string

	if s.Format != PrefixRMC {
		err := fmt.Errorf("Sentence format %s is not a RMC sentence", s.Format)
		return "", err
	}

	Raw = s.SOS + s.Talker + s.Format

	if s.UtcTimeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreRMC.UtcTime, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreRMC.UtcTime, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.StatusValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreRMC.Status

		} else {
			Raw = Raw + "," + s.CoreRMC.Status
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LatitudeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreRMC.Latitude, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreRMC.Latitude, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LatitudeDirectionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreRMC.LatitudeDirection

		} else {
			Raw = Raw + "," + s.CoreRMC.LatitudeDirection
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LongitudeValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreRMC.Longitude, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreRMC.Longitude, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.LongitudeDirectionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreRMC.LongitudeDirection

		} else {
			Raw = Raw + "," + s.CoreRMC.LongitudeDirection
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.SpeedOverGroundValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreRMC.SpeedOverGround, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreRMC.SpeedOverGround, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.CourseOverGroundValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreRMC.CourseOverGround, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreRMC.CourseOverGround, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.UtcDateValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreRMC.UtcDate), 10)

		} else {
			Raw = Raw + "," + strconv.FormatUint(uint64(s.CoreRMC.UtcDate), 10)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.MagneticVariationValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + strconv.FormatFloat(s.CoreRMC.MagneticVariation, 'f', -1, 64)

		} else {
			Raw = Raw + "," + strconv.FormatFloat(s.CoreRMC.MagneticVariation, 'f', -1, 64)
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.MagneticVariationDirectionValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreRMC.MagneticVariationDirection

		} else {
			Raw = Raw + "," + s.CoreRMC.MagneticVariationDirection
		}

	} else if len(Raw) > len(strings.TrimSuffix(Raw, ",,")) {
		Raw = Raw + ","
	} else {
		Raw = Raw + ",,"
	}

	if s.ModeIndicatorValidity == true {

		if len(Raw) > len(strings.TrimSuffix(Raw, ",")) {

			Raw = Raw + s.CoreRMC.ModeIndicator

		} else {
			Raw = Raw + "," + s.CoreRMC.ModeIndicator
		}
	}

	check := Checksum(Raw)

	Raw = Raw + check

	return Raw, nil

}
